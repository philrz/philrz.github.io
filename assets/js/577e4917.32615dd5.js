"use strict";(self.webpackChunkzed_docs=self.webpackChunkzed_docs||[]).push([[7585],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(n),h=o,u=c["".concat(s,".").concat(h)]||c[h]||m[h]||i;return n?a.createElement(u,r(r({ref:t},p),{},{components:n})):a.createElement(u,r({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4691:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return m}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),r=["components"],l={sidebar_position:1,sidebar_label:"zed"},s="zed",d={unversionedId:"commands/zed",id:"commands/zed",title:"zed",description:"TL;DR zed is a command-line tool to manage and query Zed data lakes.",source:"@site/docs/commands/zed.md",sourceDirName:"commands",slug:"/commands/zed",permalink:"/docs/next/commands/zed",editUrl:"https://github.com/brimdata/zed/tree/main/docs/commands/zed.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"zed"},sidebar:"tutorialSidebar",previous:{title:"zq",permalink:"/docs/next/commands/zq"},next:{title:"Commands",permalink:"/docs/next/tutorials/"}},p={},m=[{value:"<em>Status</em>",id:"status",level:2},{value:"1. The Lake Model",id:"1-the-lake-model",level:2},{value:"1.1 CLI-First Approach",id:"11-cli-first-approach",level:3},{value:"1.2 Storage Layer",id:"12-storage-layer",level:3},{value:"1.3 Zed Command Personalities",id:"13-zed-command-personalities",level:3},{value:"1.4 Data Pools",id:"14-data-pools",level:3},{value:"1.4.1 Commit Objects",id:"141-commit-objects",level:3},{value:"1.4.2 Commitish",id:"142-commitish",level:3},{value:"1.4.3 Pool Key",id:"143-pool-key",level:3},{value:"1.5 Time Travel",id:"15-time-travel",level:3},{value:"1.6 Search Indexes",id:"16-search-indexes",level:3},{value:"1.6.1 Index Rules",id:"161-index-rules",level:4},{value:"1.6.2 Indexing Workflows",id:"162-indexing-workflows",level:4},{value:"2. Zed Commands",id:"2-zed-commands",level:2},{value:"2.1 Auth",id:"21-auth",level:3},{value:"2.2 Branch",id:"22-branch",level:3},{value:"2.3 Create",id:"23-create",level:3},{value:"2.4 Delete",id:"24-delete",level:3},{value:"2.5 Drop",id:"25-drop",level:3},{value:"2.6 Index",id:"26-index",level:3},{value:"2.6.1 Index Apply",id:"261-index-apply",level:4},{value:"2.6.2 Index Create",id:"262-index-create",level:4},{value:"2.6.3 Index Drop",id:"263-index-drop",level:4},{value:"2.6.4 Index Ls",id:"264-index-ls",level:4},{value:"2.6.5 Index Update",id:"265-index-update",level:4},{value:"2.7 Init",id:"27-init",level:3},{value:"2.8 Load",id:"28-load",level:3},{value:"2.9 Log",id:"29-log",level:3},{value:"2.10 Merge",id:"210-merge",level:3},{value:"2.11 Query",id:"211-query",level:3},{value:"Meta-queries",id:"meta-queries",level:4},{value:"2.12 Rename",id:"212-rename",level:3},{value:"2.13 Serve",id:"213-serve",level:3},{value:"2.14 Use",id:"214-use",level:3}],c={toc:m};function h(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"zed"},"zed"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TL;DR")," ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," is a command-line tool to manage and query Zed data lakes.\nYou can import data from a variety of formats and ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," will automatically\ncommit the data in the Zed data model's ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/"},"super-structured"),"\nformat, providing full fidelity of the original format and the ability\nto reconstruct the original data without loss of information."),(0,i.kt)("p",{parentName:"blockquote"},"Zed lakes provide an easy-to-use substrate for data discovery, preparation,\nand transformation as well as serving as a queryable and searchable store\nfor super-structured data both for online and archive use cases.")),(0,i.kt)("h2",{id:"status"},(0,i.kt)("em",{parentName:"h2"},"Status")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"While ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/commands/zq"},(0,i.kt)("inlineCode",{parentName:"a"},"zq"))," and the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/"},"Zed formats"),"\nare production quality, the Zed lake is still fairly early in development\nand alpha quality.\nThat said, Zed lakes can be utilized quite effectively at small scale,\nor at larger scales when scripted automation\nis deployed to manage the lake's data layout and create any needed search indexes\nvia the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/lake/api"},"lake API"),"."),(0,i.kt)("p",{parentName:"blockquote"},"Enhanced scalability with self-tuning configuration is under development.")),(0,i.kt)("h2",{id:"1-the-lake-model"},"1. The Lake Model"),(0,i.kt)("p",null,"A Zed lake is a cloud-native arrangement of data, optimized for search,\nanalytics, ETL, data discovery, and data preparation\nat scale based on data represented in accordance\nwith the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed#zed-data-model"},"Zed data model"),"."),(0,i.kt)("p",null,"A lake is organized into a collection of data pools forming a single\nadministrative domain.  The current implementation supports\nACID append and delete semantics at the commit level while\nwe have plans to support CRUD updates at the primary-key level\nin the near future."),(0,i.kt)("p",null,"The semantics of a Zed lake loosely follows the nomenclature and\ndesign patterns of ",(0,i.kt)("a",{parentName:"p",href:"https://git-scm.com/"},(0,i.kt)("inlineCode",{parentName:"a"},"git")),".  In this approach,"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("em",{parentName:"li"},"lake")," is like a GitHub organization,"),(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("em",{parentName:"li"},"pool")," is like a ",(0,i.kt)("inlineCode",{parentName:"li"},"git")," repository,"),(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("em",{parentName:"li"},"branch")," of a ",(0,i.kt)("em",{parentName:"li"},"pool")," is like a ",(0,i.kt)("inlineCode",{parentName:"li"},"git")," branch,"),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("em",{parentName:"li"},"use"),"  command is like a ",(0,i.kt)("inlineCode",{parentName:"li"},"git checkout"),", and"),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("em",{parentName:"li"},"load")," command is like a ",(0,i.kt)("inlineCode",{parentName:"li"},"git add/commit/push"),".")),(0,i.kt)("p",null,"A core theme of the Zed lake design is ",(0,i.kt)("em",{parentName:"p"},"ergonomics"),".  Given the Git metaphor,\nour goal here is that the Zed lake tooling be as easy and familiar as Git is\nto a technical user."),(0,i.kt)("p",null,"Since Zed lakes are built around the Zed data model,\ngetting different kinds of data into and out of a lake is easy.\nThere is no need to define schemas or tables and then fit\nsemi-structured data into schemas before loading data into a lake.\nAnd because Zed supports a large family of formats and the load endpoint\nautomatically detects most formats, it's easy to just load data into a lake\nwithout thinking about how to convert it into the right format."),(0,i.kt)("h3",{id:"11-cli-first-approach"},"1.1 CLI-First Approach"),(0,i.kt)("p",null,"The Zed project has taken a ",(0,i.kt)("em",{parentName:"p"},"CLI-first approach")," to designing and implementing\nthe system.  Any time a new piece of functionality is added to the lake,\nit is first implemented as a ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," command.  This is particularly convenient\nfor testing and continuous integration as well as providing intuitive,\nbite-sized chunks for learning how the system works and how the different\ncomponents come together."),(0,i.kt)("p",null,"While the CLI-first approach provides these benefits,\nall of the functionality is also exposed through ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/lake/api"},"an API")," to\na Zed service.  Many use cases involve an application like\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/brimdata/brim"},"Brim")," or a\nprogramming environment like Python/Pandas interacting\nwith the service API in place of direct use with the ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," command."),(0,i.kt)("h3",{id:"12-storage-layer"},"1.2 Storage Layer"),(0,i.kt)("p",null,"The Zed lake storage model is designed to leverage modern cloud object stores\nand separates compute from storage."),(0,i.kt)("p",null,"A lake is entirely defined by a collection of cloud objects stored\nat a configured object-key prefix.  This prefix is called the ",(0,i.kt)("em",{parentName:"p"},"storage path"),".\nAll of the meta-data describing the data pools, branches, commit history,\nand so forth is stored as cloud objects inside of the lake.  There is no need\nto set up and manage an auxiliary metadata store."),(0,i.kt)("p",null,"Data is arranged in a lake as a set of pools, which are comprised of one\nor more branches, which consist of a sequence of data commit objects\nthat point to cloud data objects."),(0,i.kt)("p",null,"Cloud objects and commits are immutable and named with globally unique IDs,\nbased on the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/segmentio/ksuid"},"KSUIDs"),", and many\ncommands may reference various lake entities by their ID, e.g.,"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Pool ID")," - the KSUID of a pool"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Commit object ID")," - the KSUID of a commit object"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Data object ID")," - the KSUID of a committed data object"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Index rule ID")," - the KSUID of an index rule"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Index object ID")," - the KSUID of an index object relative to a data object")),(0,i.kt)("p",null,"Data is added and deleted from the lake only with new commits that\nare implemented in a transactionally consistent fashion.  Thus, each\ncommit object (identified by its globally-unique ID) provides a completely\nconsistent view of an arbitrarily large amount of committed data\nat a specific point in time."),(0,i.kt)("p",null,"While this commit model may sound heavyweight, excellent live ingest performance\ncan be achieved by micro-batching commits."),(0,i.kt)("p",null,"Because the Zed lake represents all state transitions with immutable objects,\nthe caching of any cloud object (or byte ranges of cloud objects)\nis easy and effective since a cached object is never invalid.\nThis design makes backup/restore, data migration, archive, and\nreplication easy to support and deploy."),(0,i.kt)("p",null,"The cloud objects that comprise a lake, e.g., data objects,\ncommit history, transaction journals, search indexes, partial aggregations, etc.,\nare stored as Zed data, i.e., either as ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zng"},"row-based ZNG"),"\nor ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zst"},"columnar ZST"),".\nThis makes introspection of the lake structure straightforward as many key\nlake data structures can be queried with metadata queries and presented\nto a client as Zed data for further processing by downstream tooling."),(0,i.kt)("p",null,"Zed's implementation also includes a storage abstraction that maps the cloud object\nmodel onto a file system so that Zed lakes can also be deployed on standard file systems."),(0,i.kt)("h3",{id:"13-zed-command-personalities"},"1.3 Zed Command Personalities"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," command provides a single command-line interface to Zed lakes, but\ndifferent personalities are taken on by ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," depending on the particular\nsub-command executed and the disposition of its ",(0,i.kt)("inlineCode",{parentName:"p"},"-lake")," option\n(which defaults to the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"ZED_LAKE")," environment variable or,\nif ",(0,i.kt)("inlineCode",{parentName:"p"},"ZED_LAKE")," is not set, to the client personality ",(0,i.kt)("inlineCode",{parentName:"p"},"https://localhost:9867"),")."),(0,i.kt)("p",null,"To this end, ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," can take on one of three personalities:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Direct Access")," - When the lake is a storage path (",(0,i.kt)("inlineCode",{parentName:"li"},"file")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"s3")," URI),\nthen the ",(0,i.kt)("inlineCode",{parentName:"li"},"zed")," commands (except for ",(0,i.kt)("inlineCode",{parentName:"li"},"serve"),") all operate directly on the\nlake located at that path."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Client Personality")," - When the lake is an HTTP or HTTPS URL, then the\nlake is presumed to be a Zed lake service endpoint and the client\ncommands are directed to the service managing the lake."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Server Personality")," - When the ",(0,i.kt)("inlineCode",{parentName:"li"},"zed serve")," command is executed, then\nthe personality is always the server personality and the lake must be\na storage path.  This command initiates a continuous server process\nthat serves client requests for the lake at the configured storage path.")),(0,i.kt)("p",null,"Note that a storage path on the file system may be specified either as\na fully qualified file URI of the form ",(0,i.kt)("inlineCode",{parentName:"p"},"file://")," or be a standard\nfile system path, relative or absolute, e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"/lakes/test"),"."),(0,i.kt)("p",null,"Concurrent access to any Zed lake storage, of course, preserves\ndata consistency.  You can run multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"zed serve")," processes while also\nrunning any ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," lake command all pointing at the same storage endpoint\nand the lake's data footprint will always remain consistent as the endpoints\nall adhere to the consistency semantics of the Zed lake."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"One caveat here: data consistency is not fully implemented yet for\nthe S3 endpoint so only single-node access to S3 is available right now,\nthough support for multi-node access is forthcoming.\nFor a shared file system, the close-to-open cache consistency\nsemantics of NFS should provide the necessary consistency guarantees needed by\na Zed lake though this has not been tested.  Multi-process, single-node\naccess to a local file system has been thoroughly tested and should be\ndeemed reliable, i.e., you can run a direct-access instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," alongside\na server instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," on the same file system and data consistency will\nbe maintained.")),(0,i.kt)("h3",{id:"14-data-pools"},"1.4 Data Pools"),(0,i.kt)("p",null,"A lake is made up of ",(0,i.kt)("em",{parentName:"p"},"data pools"),', which are like "collections" in NoSQL\ndocument stores.  Pools may have one or more branches and every pool always\nhas a branch called ',(0,i.kt)("inlineCode",{parentName:"p"},"main"),"."),(0,i.kt)("p",null,"A pool is created with the ",(0,i.kt)("a",{parentName:"p",href:"#23-create"},"create command"),"\nand a branch of a pool is created with the ",(0,i.kt)("a",{parentName:"p",href:"#22-branch"},"branch command"),"."),(0,i.kt)("p",null,"A pool name can be any valid UTF-8 string and is allocated a unique ID\nwhen created.  The pool can be referred to by its name or by its ID.\nA pool may be renamed but the unique ID is always fixed."),(0,i.kt)("h3",{id:"141-commit-objects"},"1.4.1 Commit Objects"),(0,i.kt)("p",null,"Data is added into a pool in atomic units called ",(0,i.kt)("em",{parentName:"p"},"commit objects"),"."),(0,i.kt)("p",null,"Each commit object is assigned a global ID.\nSimilar to Git, Zed commit objects are arranged into a tree and\nrepresent the entire commit history of the lake."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Technically speaking, Git can merge from multiple parents and thus\nGit commits form a directed acyclic graph instead of a tree;\nZed does not currently support multiple parents in the commit object history.")),(0,i.kt)("p",null,"A branch is simply a named pointer to a commit object in the Zed lake\nand like a pool, a branch name can be any valid UTF-8 string.\nConsistent updates to a branch are made by writing a new commit object that\npoints to the previous tip of the branch and updating the branch to point at\nthe new commit object.  This update may be made with a transaction constraint\n(e.g., requiring that the previous branch tip is the same as the\ncommit object's parent); if the constraint is violated, then the transaction\nis aborted."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"working branch")," of a pool may be selected on any command with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-use")," option\nor may be persisted across commands with the ",(0,i.kt)("a",{parentName:"p",href:"#214-use"},"use command")," so that\n",(0,i.kt)("inlineCode",{parentName:"p"},"-use")," does not have to be specified on each command-line.  For interactive\nworkflows, the ",(0,i.kt)("inlineCode",{parentName:"p"},"use")," command is convenient but for automated workflows\nin scripts, it is good practice to explicitly specify the branch in each\ncommand invocation with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-use")," option."),(0,i.kt)("h3",{id:"142-commitish"},"1.4.2 Commitish"),(0,i.kt)("p",null,"Many ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," commands operate with respect to a commit object.\nWhile commit objects are always referenceable by their commit ID, it is also convenient\nto refer to the commit object at the tip of a branch."),(0,i.kt)("p",null,"The entity that represents either a commit ID or a branch is called a ",(0,i.kt)("em",{parentName:"p"},"commitish"),".\nA commitish is always relative to the pool and has the form:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<pool>@<id>")," or"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<pool>@<branch>"))),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<pool>")," is a pool name or pool ID, ",(0,i.kt)("inlineCode",{parentName:"p"},"<id>")," is a commit object ID,\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"<branch>")," is a branch name."),(0,i.kt)("p",null,"In particular, the working branch set by the ",(0,i.kt)("a",{parentName:"p",href:"#214-use"},"use command")," is a commitish."),(0,i.kt)("p",null,"A commitish may be abbreviated in several ways where the missing detail is\nobtained from the working-branch commitish, e.g.,"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<pool>")," - When just a pool name is given, then the comittish is assumed to be\n",(0,i.kt)("inlineCode",{parentName:"li"},"<pool>@main"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@<id>")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"<id>"),"- When an ID is given (optionally with the ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," prefix), then the commitish is assumed to be ",(0,i.kt)("inlineCode",{parentName:"li"},"<pool>@<id>")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"<pool>")," is obtained from the working-branch commitish."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@<branch>")," - When a branch name is given with the ",(0,i.kt)("inlineCode",{parentName:"li"},"@")," prefix, then the commitish is assumed to be ",(0,i.kt)("inlineCode",{parentName:"li"},"<pool>@<id>")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"<pool>")," is obtained from the working-branch commitish.")),(0,i.kt)("p",null,"An argument to a command that takes a commit object is called a ",(0,i.kt)("em",{parentName:"p"},"commitish"),"\nsince it can be expressed as a branch or as a commit ID."),(0,i.kt)("h3",{id:"143-pool-key"},"1.4.3 Pool Key"),(0,i.kt)("p",null,"Each data pool is organized according to its configured ",(0,i.kt)("em",{parentName:"p"},"pool key"),",\nwhich is the sort key for all data stored in the lake.  Different data pools\ncan have different pool keys but all of the data in a pool must have the same\npool key."),(0,i.kt)("p",null,"As pool data is often comprised of Zed records (analogous to JSON objects),\nthe pool key is typically a field of the stored records.\nWhen pool data is not structured as records/objects (e.g., scalar or arrays or other\nnon-record types), then the pool key would typically be configured\nas the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/overview#23-the-special-value-this"},"special value ",(0,i.kt)("inlineCode",{parentName:"a"},"this")),"."),(0,i.kt)("p",null,"Data can be efficiently scanned via ranges of values conforming to the pool key."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The pool key will also serve as the primary key for the forthcoming\nCRUD semantics.")),(0,i.kt)("p",null,"A pool also has a configured sort order, either ascending or descending\nand data is organized in the pool in accordance with this order.\nData scans may be either ascending or descending, and scans that\nfollow the configured order are generally more efficient than\nscans that run in the opposing order."),(0,i.kt)("p",null,"Scans may also be range-limited but unordered."),(0,i.kt)("p",null,'Any data loaded into a pool that lacks the pool key is presumed\nto have a null value with regard to range scans.  If large amounts\nof such "keyless data" are loaded into a pool, the ability to do\nrange scans over such data is impaired.'),(0,i.kt)("h3",{id:"15-time-travel"},"1.5 Time Travel"),(0,i.kt)("p",null,'Because commits are transactional and immutable, a query\nsees its entire data scan as a fixed "snapshot" with respect to the\ncommit history.  In fact, Zed\'s ',(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/operators/from"},"from operator"),"\nallows a commit object to be specified with the ",(0,i.kt)("inlineCode",{parentName:"p"},"@")," suffix to a\npool reference, e.g.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed query 'from logs@1tRxi7zjT7oKxCBwwZ0rbaiLRxb | ...'\n")),(0,i.kt)("p",null,"In this way, a query can time-travel through the commit history.  As long as the\nunderlying data has not been deleted, arbitrarily old snapshots of the Zed\nlake can be easily queried."),(0,i.kt)("p",null,"If a writer commits data after and while a reader is scanning, then the reader\ndoes not see the new data since it's scanning the snapshot that existed\nbefore these new writes occurred."),(0,i.kt)("p",null,"Also, arbitrary metadata can be committed to the log as described below,\ne.g., to associate index objects or derived analytics to a specific\njournal commit point potentially across different data pools in\na transactionally consistent fashion."),(0,i.kt)("p",null,'While time travel through commit history provides one means to explore\npast snapshots of the commit history, another means is to use a timestamp.\nBecause the entire history of branch updates is stored in a transaction journal\nand each entry contains a timestamp, branch references can be easily\nnavigated by time.  For example, a list of branches of a pool\'s past\ncan be created by scanning the internal "pools log" and stopping at the largest\ntimestamp less than or equal to the desired timestamp.  Then using that\nhistorical snapshot of the pools, a branch can be located within the pool\nusing that pool\'s "branches log" in a similar fashion, then its corresponding\ncommit object can be used to construct the data of that branch at that\npast point in time.'),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that time travel using timestamps is a forthcoming feature.")),(0,i.kt)("h3",{id:"16-search-indexes"},"1.6 Search Indexes"),(0,i.kt)("p",null,"Unlike traditional indexing systems based on an inverted-keyword index,\nindexing in Zed is decentralized and incremental.  Instead of rolling up\nindex data structures across many data objects, a Zed lake stores a small\namount of index state for each data object.  Moreover, the design relies on\nindexes only to enhance performance, not to implement the data semantics.\nThus, indexes need not exist to operate a lake and can be incrementally added or\ndeleted without large indexing jobs needing to rebuild a monolithic index\nafter each configuration change."),(0,i.kt)("p",null,'To optimize pool scans, the lake design relies on the well-known pruning\nconcept to skip any data object that the planner determines can be skipped\nbased on one or more indexes of that object.  For example, if an object\nhas been indexed for field "foo" and the query'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'foo == "bar" | ...\n')),(0,i.kt)("p",null,'is run, then the scan will consult the "foo" index and skip the data object\nif the value "bar" is not in that index.'),(0,i.kt)("p",null,"Also, each data object is broken up into seekable chunks and the chunk location\nof each index value is stored in the index so that only parts of large\ndata objects need to be scanned based on this information."),(0,i.kt)("p",null,'This approach works well for "needle in the haystack"-style searches.  When\na search hits every object, this style of indexing would not eliminate any\nobjects and thus does not help nor does any such indexing scheme.'),(0,i.kt)("p",null,"While an individual index lookup involves latency to cloud storage to lookup\na key in each index, each lookup is cheap and involves a small amount of data\nand the lookups can all be run in parallel, even from a single node, so\nthe scan schedule can be quickly computed in a small number of round-trips\n(that navigate very wide B-trees) to cloud object storage or to a cache\nof cloud objects."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Future plans for indexing include full-text keyword indexing and\ntype-based indexing (e.g., index all values that are IP addresses\nincluding values inside arrays, sets, and sub-records).")),(0,i.kt)("h4",{id:"161-index-rules"},"1.6.1 Index Rules"),(0,i.kt)("p",null,"Indexes are created and managed with one or more ",(0,i.kt)("em",{parentName:"p"},"index rules"),"."),(0,i.kt)("p",null,"While you can simply create rules and run ",(0,i.kt)("inlineCode",{parentName:"p"},"zed index update")," to ensure\nthat indexes are all up to date with committed data, the process here\ninvolves indexing each data object and storing its index object\nas another cloud object in the data pool.  Once an index is successfully\ncomputed, the binding between a data object and its index is transactionally\ncommitted to its branch so that the query planner always has a consistent\nview of the index relative to the data."),(0,i.kt)("p",null,"When data is merged from one branch to another, the indexes are retained\nand need not be recomputed."),(0,i.kt)("p",null,"Rules are organized into groups by name and defined at the lake level\nso that any named group of rules can be applied to data objects from\nany pool.  The group name provides no meaning beyond a reference to\na set of index rules at any given time."),(0,i.kt)("p",null,"When rules are created or changed, indexes may be updated simply by running\nthe ",(0,i.kt)("a",{parentName:"p",href:"#265-index-update"},"index update command"),"."),(0,i.kt)("h4",{id:"162-indexing-workflows"},"1.6.2 Indexing Workflows"),(0,i.kt)("p",null,"Indexes are all created and managed explicitly via the ",(0,i.kt)("inlineCode",{parentName:"p"},"zed index")," commands\nand equivalent API endpoints.  It is the responsibility of external agents\nto create indexes that can be utilized by the service.  This design allows\nthe indexing system to be scaled out and run independently from the ingest\nand query functions and be tailored to diverse workloads, e.g., the needs of\na real-time log search use case are very different from those of an ETL use\ncase but this design allows different workloads like these to be custom tuned."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Agents to perform automatic indexing are under development.")),(0,i.kt)("h2",{id:"2-zed-commands"},"2. Zed Commands"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"zed")," command is structured as a primary command\nconsististing of a large number of interrelated sub-commands, similar to the\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.docker.com/engine/reference/commandline/cli/"},"docker"),"\nor ",(0,i.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands"},"kubectl"),"\ncommands."),(0,i.kt)("p",null,"The following sections describe each of the available commands, but built-in\nhelp is also available:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zed -h")," with no args displays a list of zed commands."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zed command -h"),", where ",(0,i.kt)("inlineCode",{parentName:"li"},"command")," is a sub-command, displays help\nfor that sub-command."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"zed command sub-command -h")," displays help for a sub-command of a\nsub-command and so forth.")),(0,i.kt)("h3",{id:"21-auth"},"2.1 Auth"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed auth login|logout|method|verify\n")),(0,i.kt)("p",null,"Access to a Zed lake can be secured with ",(0,i.kt)("a",{parentName:"p",href:"https://auth0.com/"},"Auth0 authentication"),".\nPlease reach out to us on our ",(0,i.kt)("a",{parentName:"p",href:"https://www.brimdata.io/join-slack/"},"Brim community Slack"),"\nif you'd like help setting this up and trying it out."),(0,i.kt)("h3",{id:"22-branch"},"2.2 Branch"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed branch [options] [name]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"branch")," command creates a branch with the name ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," that points\nto the tip of the working branch or, if the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," argument is not provided,\nlists the existing branches of the selected pool."),(0,i.kt)("p",null,"For example, this branch command"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed branch -use logs@main staging\n")),(0,i.kt)("p",null,'creates a new branch called "staging" in pool "logs", which points to\nthe same commit object as the "main" branch.  Once created, commits\nto the "staging" branch will be added to the commit history without\naffecting the "main" branch and each branch can be queried independently\nat any time.'),(0,i.kt)("p",null,"Supposing the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," branch of ",(0,i.kt)("inlineCode",{parentName:"p"},"logs"),' was already the working branch,\nthen you could create the new branch called "staging" by simply saying'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed branch staging\n")),(0,i.kt)("p",null,"Likewise, you can delete a branch with ",(0,i.kt)("inlineCode",{parentName:"p"},"-d"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed branch -d staging\n")),(0,i.kt)("p",null,"and list the branches as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed branch\n")),(0,i.kt)("h3",{id:"23-create"},"2.3 Create"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed create [-orderby key[,key...][:asc|:desc]] <name>\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"create")," command creates a new data pool with the given name,\nwhich may be any valid UTF-8 string."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"-orderby")," option indicates the pool key that is used to sort\nthe data in lake, which may be in ascending or descending order."),(0,i.kt)("p",null,"If a pool key is not specified, then it defaults to\nthe ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/overview#23-the-special-value-this"},"special value ",(0,i.kt)("inlineCode",{parentName:"a"},"this")),"."),(0,i.kt)("p",null,"A newly created pool is initialized with a branch called ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'Zed lakes can be used without thinking about branches.  When referencing a pool without\na branch, the tooling presumes the "main" branch as the default, and everything\ncan be done on main without having to think about branching.')),(0,i.kt)("h3",{id:"24-delete"},"2.4 Delete"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed delete [options] <id> [<id>...]\nzed delete [options] -where <filter>\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"delete")," command removes one or more data objects indicated by their ID from a pool.\nThis command\nsimply removes the data from the branch without actually deleting the\nunderlying data objects thereby allowing time travel to work in the face\nof deletes."),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},"-where")," flag is specified, delete will remove all values for which the\nprovided filter expression is true. The filter expression must be a single comparison\nagainst the pool key using <, <=, > or >= (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"-where 'ts <= now() - 3h'"),")."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A vacuum command to delete permanently from a pool is under development.")),(0,i.kt)("h3",{id:"25-drop"},"2.5 Drop"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed drop [options] <name>|<id>\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"drop")," command deletes a pool and all of its constituent data.\nAs this is a DANGER ZONE command, you must confirm that you want to delete\nthe pool to proceed.  The ",(0,i.kt)("inlineCode",{parentName:"p"},"-f")," option can be used to force the deletion\nwithout confirmation."),(0,i.kt)("h3",{id:"26-index"},"2.6 Index"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed index [options] apply|create|drop|ls|update\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"index")," command has a number of sub-commands to create, manage, and delete\nindexing rules and apply these rules to create indexes of data objects."),(0,i.kt)("h4",{id:"261-index-apply"},"2.6.1 Index Apply"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed index apply [options ]<rule> <id> [<id>, ...]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"index apply")," command applies the indexing rules defined by the\nindex name ",(0,i.kt)("inlineCode",{parentName:"p"},"<rule>")," to one or more data object IDs given by the\n",(0,i.kt)("inlineCode",{parentName:"p"},"<id>")," arguments to create new index objects."),(0,i.kt)("p",null,"The new objects are recorded in a new commit object in the working branch\n(or in the branch indicated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-use")," option.)  The options used to\nset metadata in the ",(0,i.kt)("a",{parentName:"p",href:"#28-load"},"load command")," may also be specified here."),(0,i.kt)("h4",{id:"262-index-create"},"2.6.2 Index Create"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed index create <rule> field <field>\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"index create")," command creates a field rule under the group of\nrules called ",(0,i.kt)("inlineCode",{parentName:"p"},"<rule>")," for the field referenced by ",(0,i.kt)("inlineCode",{parentName:"p"},"<field>"),", which should\nbe an identifier or dotted-field path."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed index create IndexGroupExample field foo\n")),(0,i.kt)("p",null,"adds a field rule for field ",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," to the index group named ",(0,i.kt)("inlineCode",{parentName:"p"},"IndexGroupExample"),".\nThis rule can then be applied to a data object having a given ",(0,i.kt)("inlineCode",{parentName:"p"},"<id>"),"\nin a pool, e.g.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed index apply -use logs@main IndexGroupExample <id>\n")),(0,i.kt)("p",null,"The index is created and transactionally added to the working branch's\ncommit history so it becomes available to the query optimizer."),(0,i.kt)("h4",{id:"263-index-drop"},"2.6.3 Index Drop"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed index drop <id> [<id> ...]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"index drop")," command deletes one or more index rules specified by ",(0,i.kt)("inlineCode",{parentName:"p"},"<id>"),".\nOnce deleted, no more indexes will be created for that rule but the underlying\nindexes are not actually deleted from the lake."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Commands to delete the underlying indexes and data from a lake are\nunder development.")),(0,i.kt)("h4",{id:"264-index-ls"},"2.6.4 Index Ls"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed index ls [options]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"index ls")," command lists the indexes organized by groups that are\nconfigured in the lake."),(0,i.kt)("h4",{id:"265-index-update"},"2.6.5 Index Update"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed index update [rule [rule ...]]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"index update")," command creates index objects for all data objects\nin the working branch (or the branch specified by ",(0,i.kt)("inlineCode",{parentName:"p"},"-use"),")\nthat do not have an index object for the list of index rules given."),(0,i.kt)("p",null,"If no index rules are given, the update is performed for all index rules."),(0,i.kt)("h3",{id:"27-init"},"2.7 Init"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed init [path]\n")),(0,i.kt)("p",null,"A new lake is initialized with the ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," command.  The ",(0,i.kt)("inlineCode",{parentName:"p"},"path")," argument\nis a ",(0,i.kt)("a",{parentName:"p",href:"#12-storage-layer"},"storage path")," and is optional.  If not present,\nthe path is taken from the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZED_LAKE")," environment variable, which must be defined."),(0,i.kt)("p",null,"If the lake already exists, ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," reports an error and does nothing."),(0,i.kt)("p",null,"Otherwise, the ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," command writes the initial cloud objects to the\nstorage path to create a new, empty lake at the specified path."),(0,i.kt)("h3",{id:"28-load"},"2.8 Load"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed load [options] input [input ...]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"load")," command commits new data to a branch of a pool."),(0,i.kt)("p",null,"Run ",(0,i.kt)("inlineCode",{parentName:"p"},"zed load -h")," for a list of command-line options."),(0,i.kt)("p",null,'Note that there is no need to define a schema or insert data into\na "table" as all Zed data is ',(0,i.kt)("em",{parentName:"p"},"self describing")," and can be queried in a\nschema-agnostic fashion.  Data of any ",(0,i.kt)("em",{parentName:"p"},"shape")," can be stored in any pool\nand arbitrary data ",(0,i.kt)("em",{parentName:"p"},"shapes")," can coexist side by side."),(0,i.kt)("p",null,"As with ",(0,i.kt)("inlineCode",{parentName:"p"},"zq"),",\nthe ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/commands/zq#1-usage"},"input arguments")," can be in\nany ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/commands/zq#2-input-formats"},"supported format")," and\nthe input format is auto-detected if ",(0,i.kt)("inlineCode",{parentName:"p"},"-i")," is not provided.  Likewise,\nthe inputs may be URLs, in which case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"load")," command streams\nthe data from a Web server or S3 and into the lake."),(0,i.kt)("p",null,"When data is loaded, it is broken up into objects of a target size determined\nby the pool's ",(0,i.kt)("inlineCode",{parentName:"p"},"threshold")," parameter (which defaults 500MiB but can be configured\nwhen the pool is created).  Each object is sorted by the pool key but\na sequence of objects is not guaranteed to be globally sorted.  When lots\nof small or unsorted commits occur, data can be fragmented impacting performance."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that data is easily compacted by reading from a fragmented pool and writing\nit back to a target pool so that it is globally sorted and compacted into\ncontiguous large objects.  We will soon introduce a compaction feature that\ndoes this automatically inside of a pool and can either be run manually or\nconfigured to run automatically by the server.")),(0,i.kt)("p",null,"For example, this command"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed load sample1.json sample2.zng sample3.zson\n")),(0,i.kt)("p",null,"loads files of varying formats in a single commit to the working branch."),(0,i.kt)("p",null,"Parquet and ZST formats are not auto-detected so you must currently\nspecify ",(0,i.kt)("inlineCode",{parentName:"p"},"-i")," with these formats, e.g.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed load -i parquet sample4.parquet\nzed load -i zst sample5.zst\n")),(0,i.kt)("p",null,"An alternative branch may be specified with a branch reference with the\n",(0,i.kt)("inlineCode",{parentName:"p"},"-use")," option, i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"<pool>@<branch>"),".  Supposing a branch\ncalled ",(0,i.kt)("inlineCode",{parentName:"p"},"live")," existed, data can be committed into this branch as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed load -use logs@live sample.zng\n")),(0,i.kt)("p",null,"Or, as mentioned above, you can set the default branch for the load command\nvia ",(0,i.kt)("inlineCode",{parentName:"p"},"use"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed use logs@live\nzed load sample.zng\n")),(0,i.kt)("p",null,"During a ",(0,i.kt)("inlineCode",{parentName:"p"},"load")," operation, a commit is broken out into units called ",(0,i.kt)("em",{parentName:"p"},"data objects"),"\nwhere a target object size is configured into the pool,\ntypically 100MB-1GB.  The records within each object are sorted by the pool key.\nA data object is presumed by the implementation\nto fit into the memory of an intake worker node\nso that such a sort can be trivially accomplished."),(0,i.kt)("p",null,"Data added to a pool can arrive in any order with respect to the pool key.\nWhile each object is sorted before it is written,\nthe collection of objects is generally not sorted."),(0,i.kt)("p",null,"Each load operation creates a single commit object, which includes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"an author and message string,"),(0,i.kt)("li",{parentName:"ul"},"a timestamp computed by the server, and"),(0,i.kt)("li",{parentName:"ul"},"an optional metadata field of any Zed type expressed as a ZSON value.\nThis data has the Zed type signature:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{\n    author: string,\n    date: time,\n    message: string,\n    meta: <any>\n}\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<any>")," is the type of any optionally attached metadata .\nFor example, this command sets the ",(0,i.kt)("inlineCode",{parentName:"p"},"author")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"message")," fields:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'zed load -user user@example.com -message "new version of prod dataset" ...\n')),(0,i.kt)("p",null,"If these fields are not specified, then the Zed system will fill them in\nwith the user obtained from the session and a message that is descriptive\nof the action."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"date")," field here is used by the Zed lake system to do time travel\nthrough the branch and pool history, allowing you to see the state of\nbranches at any time in their commit history."),(0,i.kt)("p",null,"Arbitrary metadata expressed as any ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zson"},"ZSON value"),"\nmay be attached to a commit via the ",(0,i.kt)("inlineCode",{parentName:"p"},"-meta")," flag.  This allows an application\nor user to transactionally commit metadata alongside committed data for any\npurpose.  This approach allows external applications to implement arbitrary\ndata provenance and audit capabilities by embedding custom metadata in the\ncommit history."),(0,i.kt)("p",null,"Since commit objects are stored as Zed, the metadata can easily be\nqueried by running the ",(0,i.kt)("inlineCode",{parentName:"p"},"log -f zng")," to retrieve the log in ZNG format,\nfor example, and using ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/commands/zq"},(0,i.kt)("inlineCode",{parentName:"a"},"zq"))," to pull the metadata out\nas in:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed log -f zng | zq 'has(meta) | yield {id,meta}' -\n")),(0,i.kt)("h3",{id:"29-log"},"2.9 Log"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed log [options] [commitish]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," command, like ",(0,i.kt)("inlineCode",{parentName:"p"},"git log"),", displays a history of the commit objects\nstarting from any commit, expressed as a ",(0,i.kt)("a",{parentName:"p",href:"#142-commitish"},"commitish"),".  If no argument is\ngiven, the tip of the working branch is used."),(0,i.kt)("p",null,"Run ",(0,i.kt)("inlineCode",{parentName:"p"},"zed log -h")," for a list of command-line options."),(0,i.kt)("p",null,"To understand the log contents, the ",(0,i.kt)("inlineCode",{parentName:"p"},"load"),' operation is actually\ndecomposed into two steps under the covers:\nan "add" step stores one or more\nnew immutable data objects in the lake and a "commit" step\nmaterializes the objects into a branch with an ACID transaction.\nThis updates the branch pointer to point at a new commit object\nreferencing the data objects where the new commit object\'s parent\npoints at the branch\'s previous commit object, thus forming a path\nthrough the object tree.'),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," command prints the commit ID of each commit object in that path\nfrom the current pointer back through history to the first commit object."),(0,i.kt)("p",null,"A commit object includes\nan optional author and message, along with a required timestamp,\nthat is stored in the commit journal for reference.  These values may\nbe specified as options to the ",(0,i.kt)("inlineCode",{parentName:"p"},"load")," command, and are also available in the\nAPI for automation."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that the branchlog meta-query source is not yet implemented.")),(0,i.kt)("h3",{id:"210-merge"},"2.10 Merge"),(0,i.kt)("p",null,"Data is merged from one branch into another with the ",(0,i.kt)("inlineCode",{parentName:"p"},"merge")," command, e.g.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed merge -use logs@updates main\n")),(0,i.kt)("p",null,"where the ",(0,i.kt)("inlineCode",{parentName:"p"},"updates")," branch is being merged into the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," branch\nwithin the ",(0,i.kt)("inlineCode",{parentName:"p"},"logs")," pool."),(0,i.kt)("p",null,"A merge operation finds a common ancestor in the commit history then\ncomputes the set of changes needed for the target branch to reflect the\ndata additions and deletions in the source branch.\nWhile the merge operation is performed, data can still be written concurrently\nto both branches and queries performed and everything remains transactionally\nconsistent.  Newly written data remains in the\nbranch while all of the data present at merge initiation is merged into the\nparent."),(0,i.kt)("p",null,"This Git-like behavior for a data lake provides a clean solution to\nthe live ingest problem.\nFor example, data can be continuously ingested into a branch of main called ",(0,i.kt)("inlineCode",{parentName:"p"},"live"),"\nand orchestration logic can periodically merge updates from branch ",(0,i.kt)("inlineCode",{parentName:"p"},"live")," to\nbranch ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),", possibly compacting and indexing data after the merge\naccording to configured policies and logic."),(0,i.kt)("h3",{id:"211-query"},"2.11 Query"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed query [options] <query>\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"query")," command runs a Zed program with data from a lake as input.\nA query typically begins with a ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/operators/from"},"from operator"),"\nindicating the pool and branch to use as input.  If ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," is not present, then the\nquery reads from the working branch."),(0,i.kt)("p",null,"The pool/branch names\nare specified with ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," at the beginning of the Zed query along with an optional\ntime range using ",(0,i.kt)("inlineCode",{parentName:"p"},"range")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"to"),"."),(0,i.kt)("p",null,"As with ",(0,i.kt)("inlineCode",{parentName:"p"},"zq"),", the default output format is ZSON for\nterminals and ZNG otherwise, though this can be overridden with\n",(0,i.kt)("inlineCode",{parentName:"p"},"-f")," to specify one of the various supported output formats."),(0,i.kt)("p",null,"If a pool name is provided to ",(0,i.kt)("inlineCode",{parentName:"p"},"from"),' without a branch name, then branch\n"main" is assumed.'),(0,i.kt)("p",null,"This example reads every record from the full key range of the ",(0,i.kt)("inlineCode",{parentName:"p"},"logs")," pool\nand sends the results to stdout."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed query 'from logs'\n")),(0,i.kt)("p",null,"We can narrow the span of the query by specifying the key range, where these\nvalues refer to the pool key:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed query 'from logs range 2018-03-24T17:36:30.090766Z to 2018-03-24T17:36:30.090758Z'\n")),(0,i.kt)("p",null,"These range queries are efficiently implemented as the data is laid out\naccording to the pool key and seek indexes keyed by the pool key\nare computed for each data object."),(0,i.kt)("p",null,"Lake queries also can refer to HEAD (i.e., the branch context set in the most\nrecent ",(0,i.kt)("inlineCode",{parentName:"p"},"use")," command) either implicitly by omitting the ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed query '*'\n")),(0,i.kt)("p",null,"or by referencing ",(0,i.kt)("inlineCode",{parentName:"p"},"HEAD"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed query 'from HEAD'\n")),(0,i.kt)("p",null,"When querying data to the ZNG output format,\noutput from a pool can be easily piped to other commands like ",(0,i.kt)("inlineCode",{parentName:"p"},"zq"),", e.g.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed query -f zng 'from logs' | zq -f table 'count() by field' -\n")),(0,i.kt)("p",null,"Of course, it's even more efficient to run the query inside of the pool traversal\nlike this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed query -f table 'from logs | count() by field'\n")),(0,i.kt)("p",null,"By default, the ",(0,i.kt)("inlineCode",{parentName:"p"},"query")," command scans pool data in pool-key order though\nthe Zed optimizer may, in general, reorder the scan to optimize searches,\naggregations, and joins.\nAn order hint can be supplied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"query")," command to indicate to\nthe optimizer the desired processing order, but in general, ",(0,i.kt)("inlineCode",{parentName:"p"},"sort")," operators\nshould be used to guarantee any particular sort order."),(0,i.kt)("p",null,"Arbitrarily complex Zed queries can be executed over the lake in this fashion\nand the planner can utilize cloud resources to parallelize and scale the\nquery over many parallel workers that simultaneously access the Zed lake data in\nshared cloud storage (while also accessing locally- or cluster-cached copies of data)."),(0,i.kt)("h4",{id:"meta-queries"},"Meta-queries"),(0,i.kt)("p",null,"Commit history, metadata about data objects, lake and pool configuration,\netc. can all be queried and\nreturned as Zed data, which in turn, can be fed into Zed analytics.\nThis allows a very powerful approach to introspecting the structure of a\nlake making it easy to measure, tune, and adjust lake parameters to\noptimize layout for performance."),(0,i.kt)("p",null,"These structures are introspected using meta-queries that simply\nspecify a metadata source using an extended syntax in the ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," operator.\nThere are three types of meta-queries:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"from :<meta>")," - lake level"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"from pool:<meta>")," - pool level"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"from pool@branch<:meta>")," - branch level")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"<meta>")," is the name of the metadata being queried. The available metadata\nsources vary based on level."),(0,i.kt)("p",null,"For example, a list of pools with configuration data can be obtained\nin the ZSON format as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'zed query -Z "from :pools"\n')),(0,i.kt)("p",null,"This meta-query produces a list of branches in a pool called ",(0,i.kt)("inlineCode",{parentName:"p"},"logs"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'zed query -Z "from logs:branches"\n')),(0,i.kt)("p",null,"Since this is all just Zed, you can filter the results just like any query,\ne.g., to look for particular branch:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed query -Z \"from logs:branches | branch.name=='main'\"\n")),(0,i.kt)("p",null,"This meta-query produces a list of the data objects in the ",(0,i.kt)("inlineCode",{parentName:"p"},"live")," branch\nof pool ",(0,i.kt)("inlineCode",{parentName:"p"},"logs"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'zed query -Z "from logs@live:objects"\n')),(0,i.kt)("p",null,'You can also pretty-print in human-readable form most of the metadata Zed records\nusing the "lake" format, e.g.,'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'zed query -f lake "from logs@live:objects"\n')),(0,i.kt)("h3",{id:"212-rename"},"2.12 Rename"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed rename <existing> <new-name>\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"rename")," command assigns a new name ",(0,i.kt)("inlineCode",{parentName:"p"},"<new-name>")," to an existing\npool ",(0,i.kt)("inlineCode",{parentName:"p"},"<existing>"),", which may be referenced by its ID or its previous name."),(0,i.kt)("h3",{id:"213-serve"},"2.13 Serve"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed serve [options]\n")),(0,i.kt)("p",null,"The serve command implements Zed's server personality to service requests\nfrom instances of Zed's client personality.\nIt listens for Zed lake API requests on the interface and port\nspecified by the ",(0,i.kt)("inlineCode",{parentName:"p"},"-l")," option, executes the requests, and returns results."),(0,i.kt)("h3",{id:"214-use"},"2.14 Use"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed use [<commitish>]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"use")," command sets the working branch to the indicated commitish.\nWhen run without a commitish argument, it displays the current commitish\nin use."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed use logs\n")),(0,i.kt)("p",null,'provides a "pool-only" commitish that sets the working branch to ',(0,i.kt)("inlineCode",{parentName:"p"},"logs@main"),"."),(0,i.kt)("p",null,"If a ",(0,i.kt)("inlineCode",{parentName:"p"},"@branch")," or commit ID are given without a pool prefix, then the pool of\nthe commitish previously in use is presumed.  For example, if you are on\n",(0,i.kt)("inlineCode",{parentName:"p"},"logs@main")," then run this command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed use @test\n")),(0,i.kt)("p",null,"then the working branch is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"logs@test"),"."),(0,i.kt)("p",null,"To specify a branch in another pool, simply prepend\nthe pool name to the desired branch:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zed use otherpool@otherbranch\n")),(0,i.kt)("p",null,"This command stores the working branch in ",(0,i.kt)("inlineCode",{parentName:"p"},"$HOME/.zed_head"),"."))}h.isMDXComponent=!0}}]);