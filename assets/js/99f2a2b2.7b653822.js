"use strict";(self.webpackChunkzed_docs=self.webpackChunkzed_docs||[]).push([[2866],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return k}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),d=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=d(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=d(n),k=r,c=u["".concat(o,".").concat(k)]||u[k]||m[k]||i;return n?a.createElement(c,l(l({ref:t},s),{},{components:n})):a.createElement(c,l({ref:t},s))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:r,l[1]=p;for(var d=2;d<i;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2320:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return o},default:function(){return k},frontMatter:function(){return p},metadata:function(){return d},toc:function(){return m}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],p={sidebar_position:2,sidebar_label:"ZSON"},o="ZSON Specification",d={unversionedId:"formats/zson",id:"formats/zson",title:"ZSON Specification",description:"1. Introduction",source:"@site/docs/formats/zson.md",sourceDirName:"formats",slug:"/formats/zson",permalink:"/docs/next/formats/zson",editUrl:"https://github.com/brimdata/zed/tree/current/formats/zson.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"ZSON"},sidebar:"tutorialSidebar",previous:{title:"ZNG",permalink:"/docs/next/formats/zng"},next:{title:"ZST",permalink:"/docs/next/formats/zst"}},s={},m=[{value:"1. Introduction",id:"1-introduction",level:2},{value:"2. The ZSON Format",id:"2-the-zson-format",level:2},{value:"2.1 Names",id:"21-names",level:3},{value:"2.2 Type Decorators",id:"22-type-decorators",level:3},{value:"2.3 Primitive Values",id:"23-primitive-values",level:3},{value:"2.3.1 Strings",id:"231-strings",level:4},{value:"2.4 Complex Values",id:"24-complex-values",level:3},{value:"2.4.1 Record Value",id:"241-record-value",level:4},{value:"2.4.2 Array Value",id:"242-array-value",level:4},{value:"2.4.3 Set Value",id:"243-set-value",level:4},{value:"2.4.4 Map Value",id:"244-map-value",level:4},{value:"2.4.5 Union Value",id:"245-union-value",level:4},{value:"2.4.6 Enum Value",id:"246-enum-value",level:4},{value:"2.4.7 Error Value",id:"247-error-value",level:4},{value:"2.5 Types",id:"25-types",level:3},{value:"2.5.1 Record Type",id:"251-record-type",level:4},{value:"2.5.2 Array Type",id:"252-array-type",level:4},{value:"2.5.3 Set Type",id:"253-set-type",level:4},{value:"2.5.4 Map Type",id:"254-map-type",level:4},{value:"2.5.5 Union Type",id:"255-union-type",level:4},{value:"2.5.6 Enum Type",id:"256-enum-type",level:4},{value:"2.5.7 Error Type",id:"257-error-type",level:4},{value:"2.5.8 Named Type",id:"258-named-type",level:4},{value:"2.6 Null Value",id:"26-null-value",level:3},{value:"3. Examples",id:"3-examples",level:2},{value:"4. Grammar",id:"4-grammar",level:2}],u={toc:m};function k(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"zson-specification"},"ZSON Specification"),(0,i.kt)("h2",{id:"1-introduction"},"1. Introduction"),(0,i.kt)("p",null,"ZSON is the human-readable, text-based serialization format of\nthe super-structured ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed"},"Zed data model"),"."),(0,i.kt)("p",null,'ZSON builds upon the elegant simplicity of JSON with "type decorators".\nWhere the type of a value is not implied by its syntax, a parenthesized\ntype decorator is appended to the value thus establishing a well-defined\ntype for every value expressed in ZSON text.'),(0,i.kt)("p",null,"ZSON is also a superset of JSON in that all JSON documents are valid ZSON values."),(0,i.kt)("h2",{id:"2-the-zson-format"},"2. The ZSON Format"),(0,i.kt)("p",null,"A ZSON text is a sequence of UTF-8 characters organized either as a bounded input\nor an unbounded stream."),(0,i.kt)("p",null,"The input text is organized as a sequence of one or more Zed values optionally\nseparated by and interspersed with whitespace.\nSingle-line (",(0,i.kt)("inlineCode",{parentName:"p"},"//"),") and multi-line (",(0,i.kt)("inlineCode",{parentName:"p"},"/* ... */"),") comments are\ntreated as whitespace and ignored."),(0,i.kt)("p",null,"All subsequent references to characters and strings in this section refer to\nthe Unicode code points that result when the stream is decoded.\nIf a ZSON input includes data that is not valid UTF-8, the input is invalid."),(0,i.kt)("h3",{id:"21-names"},"2.1 Names"),(0,i.kt)("p",null,"ZSON ",(0,i.kt)("em",{parentName:"p"},"names")," encode record fields, enum symbols, and named types.\nA name is either an ",(0,i.kt)("em",{parentName:"p"},"identifier")," or a ",(0,i.kt)("a",{parentName:"p",href:"#231-strings"},"quoted string"),".\nNames are referred to as ",(0,i.kt)("inlineCode",{parentName:"p"},"<name>")," below."),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"identifier")," is case-sensitive and can contain Unicode letters, ",(0,i.kt)("inlineCode",{parentName:"p"},"$"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"_"),",\nand digits (0-9), but may not start with a digit.  An identifier cannot be\n",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,i.kt)("h3",{id:"22-type-decorators"},"2.2 Type Decorators"),(0,i.kt)("p",null,"A value may be explicitly typed by tagging it with a type decorator.\nThe syntax for a decorator is a parenthesized type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<value> ( <type> )\n")),(0,i.kt)("p",null,"For union values, multiple decorators might be\nrequired to distinguish the union-member type from the possible set of\nunion types when there is ambiguity, as in"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"123 (float64) (int64,float64)\n")),(0,i.kt)("p",null,"In contrast, this union value is unambiguous:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"123.0 (int64,float64)\n")),(0,i.kt)("p",null,"The syntax of a union value decorator is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<value> ( <type> ) [ ( <type> ) ...]\n")),(0,i.kt)("p",null,"where the rightmost type must be a union type if more than one decorator\nis present."),(0,i.kt)("p",null,"A decorator may also define a ",(0,i.kt)("a",{parentName:"p",href:"#258-named-type"},"named type"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<value> ( =<name> )\n")),(0,i.kt)("p",null,"which declares a new type with the indicated type name using the\nimplied type of the value.  Type names may not be numeric, where a\nnumeric is a sequence of one or more characters in the set ",(0,i.kt)("inlineCode",{parentName:"p"},"[0-9]"),"."),(0,i.kt)("p",null,"A decorator may also defined a temporary numeric reference of the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<value> ( =<numeric> )\n")),(0,i.kt)("p",null,"Once defined, this numeric reference may then be used anywhere a named type\nis used but a named type is not created."),(0,i.kt)("p",null,"It is an error for the decorator to be type incompatible with its referenced value.  "),(0,i.kt)("p",null,"Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," sigil here disambiguates between the case that a new\ntype is defined, which may override a previous definition of a different type with the\nsame name, from the case that an existing named type is merely decorating the value."),(0,i.kt)("h3",{id:"23-primitive-values"},"2.3 Primitive Values"),(0,i.kt)("p",null,"The type names and format for\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed#1-primitive-types"},"Zed primitive")," values is as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Value Format"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint8")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any unsigned, 8-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint16")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any unsigned, 16-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint32")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any unsigned, 32-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint64")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any unsigned, 64-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint128")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any unsigned, 128-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint256")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any unsigned, 256-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int8")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any signed, 8-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int16")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any signed, 16-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int32")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any signed, 32-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int64")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any signed, 64-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int128")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any signed, 128-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int256")),(0,i.kt)("td",{parentName:"tr",align:null},"decimal string representation of any signed, 256-bit integer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"duration")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"duration string")," representing signed 64-bit nanoseconds")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"time")),(0,i.kt)("td",{parentName:"tr",align:null},"an RFC 3339 UTC date/time string representing signed 64-bit nanoseconds from epoch")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float16")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"non-integer string")," representing an IEEE-754 binary16 value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float32")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"non-integer string")," representing an IEEE-754 binary32 value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float64")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"non-integer string")," representing an IEEE-754 binary64 value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float128")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"non-integer string")," representing an IEEE-754 binary128 value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float256")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"non-integer string")," representing an IEEE-754 binary256 value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"decimal32")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"non-integer string")," representing an IEEE-754 decimal32 value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"decimal64")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"non-integer string")," representing an IEEE-754 decimal64 value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"decimal128")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"non-integer string")," representing an IEEE-754 decimal128 value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"decimal256")),(0,i.kt)("td",{parentName:"tr",align:null},"a ",(0,i.kt)("em",{parentName:"td"},"non-integer string")," representing an IEEE-754 decimal256 value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bool")),(0,i.kt)("td",{parentName:"tr",align:null},"the string ",(0,i.kt)("inlineCode",{parentName:"td"},"true")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"false"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bytes")),(0,i.kt)("td",{parentName:"tr",align:null},"a sequence of bytes encoded as a hexadecimal string prefixed with ",(0,i.kt)("inlineCode",{parentName:"td"},"0x"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:null},"a double-quoted or backtick-quoted UTF-8 string")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ip")),(0,i.kt)("td",{parentName:"tr",align:null},"a string representing an IP address in ",(0,i.kt)("a",{parentName:"td",href:"https://tools.ietf.org/html/draft-main-ipaddr-text-rep-02#section-3"},"IPv4 or IPv6 format"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"net")),(0,i.kt)("td",{parentName:"tr",align:null},"a string in CIDR notation representing an IP address and prefix length as defined in RFC 4632 and RFC 4291.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"type")),(0,i.kt)("td",{parentName:"tr",align:null},"a string in canonical form as described in ",(0,i.kt)("a",{parentName:"td",href:"#25-types"},"Section 2.5"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"null")),(0,i.kt)("td",{parentName:"tr",align:null},"the string ",(0,i.kt)("inlineCode",{parentName:"td"},"null"))))),(0,i.kt)("p",null,"The format of a ",(0,i.kt)("em",{parentName:"p"},"duration string"),'\nis an optionally-signed concatenation of decimal numbers,\neach with optional fraction and a unit suffix,\nsuch as "300ms", "-1.5h" or "2h45m", representing a 64-bit nanosecond value.\nValid time units are\n"ns" (nanosecond),\n"us" (microsecond),\n"ms" (millisecond),\n"s" (second),\n"m" (minute),\n"h" (hour),\n"d" (day),\n"w" (7 days), and\n"y" (365 days).\nNote that each of these time units accurately represents its calendar value,\nexcept for the "y" unit, which does not reflect leap years and so forth.\nInstead, "y" is defined as the number of nanoseconds in 365 days.'),(0,i.kt)("p",null,"The format of floating point values is a ",(0,i.kt)("em",{parentName:"p"},"non-integer string"),"\nconforming to any floating point representation that cannot be\ninterpreted as an integer, e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"1.")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1.0")," instead of\n",(0,i.kt)("inlineCode",{parentName:"p"},"1")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1e3")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"1000"),".  Unlike JSON, a floating point number can\nalso be one of:\n",(0,i.kt)("inlineCode",{parentName:"p"},"Inf"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"+Inf"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"-Inf"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"Nan"),"."),(0,i.kt)("p",null,"A floating point value may be expressed with an integer string provided\na type decorator is applied, e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"123 (float64)"),"."),(0,i.kt)("p",null,"Decimal values require type decorators."),(0,i.kt)("p",null,"A string may be backtick-quoted with the backtick character ",(0,i.kt)("inlineCode",{parentName:"p"},"`"),".\nNone of the text between backticks is escaped, but by default, any newlines\nfollowed by whitespace are converted to a single newline and the first\nnewline of the string is deleted.  To avoid this automatic deletion and\npreserve indentation, the backtick-quoted string can be preceded with ",(0,i.kt)("inlineCode",{parentName:"p"},"=>"),"."),(0,i.kt)("p",null,"Of the 30 primitive types, eleven of them represent ",(0,i.kt)("em",{parentName:"p"},"implied-type")," values:\n",(0,i.kt)("inlineCode",{parentName:"p"},"int64"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"time"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"duration"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"float64"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"ip"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"net"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"type"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),".\nValues for these types are determined by the format of the value and\nthus do not need decorators to clarify the underlying type, e.g.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"123 (int64)\n")),(0,i.kt)("p",null,"is the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"123"),"."),(0,i.kt)("p",null,"Values that do not have implied types must include a type decorator to clarify\nits type or appear in a context for which its type is defined (i.e., as a field\nvalue in a record, as an element in an array, etc.)."),(0,i.kt)("p",null,"While a ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," value may represent a complex type, the value itself is a singleton\nand thus always a primitive type.  A ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," value is encoded as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a left angle bracket ",(0,i.kt)("inlineCode",{parentName:"li"},"<"),", followed by"),(0,i.kt)("li",{parentName:"ul"},"a type as ",(0,i.kt)("a",{parentName:"li",href:"#25-types"},"encoded below"),", followed by"),(0,i.kt)("li",{parentName:"ul"},"a right angle bracket ",(0,i.kt)("inlineCode",{parentName:"li"},">"),".")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," value corresponds to 64-bit Unix epoch nanoseconds and thus\nnot all possible RFC 3339 date/time strings are valid.  In addition,\nnanosecond epoch times overflow on April 11, 2262.\nFor the world of 2262, a new epoch can be created well in advance\nand the old time epoch and new time epoch can live side by side with\nthe old using a named type for the new epoch time defined as the old ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," type.\nAn app that requires more than 64 bits of timestamp precision can always use\na typedef of a ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," type and do its own conversions to and from the\ncorresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," values."),(0,i.kt)("h4",{id:"231-strings"},"2.3.1 Strings"),(0,i.kt)("p",null,"Double-quoted ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," syntax is the same as that of JSON as described\nin ",(0,i.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc8259#section-7"},"RFC 8259"),".  Notably,\nthe following escape sequences are recognized:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Sequence"),(0,i.kt)("th",{parentName:"tr",align:null},"Unicode Character"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},'\\"')),(0,i.kt)("td",{parentName:"tr",align:null},"quotation mark  U+0022")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\\\")),(0,i.kt)("td",{parentName:"tr",align:null},"reverse solidus U+005C")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\/")),(0,i.kt)("td",{parentName:"tr",align:null},"solidus         U+002F")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\b")),(0,i.kt)("td",{parentName:"tr",align:null},"backspace       U+0008")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\f")),(0,i.kt)("td",{parentName:"tr",align:null},"form feed       U+000C")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\n")),(0,i.kt)("td",{parentName:"tr",align:null},"line feed       U+000A")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\r")),(0,i.kt)("td",{parentName:"tr",align:null},"carriage return U+000D")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\t")),(0,i.kt)("td",{parentName:"tr",align:null},"tab             U+0009")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\uXXXX")),(0,i.kt)("td",{parentName:"tr",align:null},"U+XXXX")))),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"\\uXXXX")," sequences, each ",(0,i.kt)("inlineCode",{parentName:"p"},"X")," is a hexadecimal digit, and letter\ndigits may be uppercase or lowercase."),(0,i.kt)("p",null,"The behavior of an implementation that encounters an unrecognized escape\nsequence in a ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," type is undefined."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"\\u")," followed by anything that does not conform to the above syntax\nis not a valid escape sequence.  The behavior of an implementation\nthat encounters such invalid sequences in a ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," type is undefined."),(0,i.kt)("p",null,"These escaping rules apply also to quoted field names in record values and\nrecord types as well as enum symbols."),(0,i.kt)("h3",{id:"24-complex-values"},"2.4 Complex Values"),(0,i.kt)("p",null,"Complex values are built from primitive values and/or other complex values\nand conform to the Zed data model's complex types:\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed#21-record"},"record"),",\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed#22-array"},"array"),",\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed#23-set"},"set"),",\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed#24-map"},"map"),",\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed#25-union"},"union"),",\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed#26-enum"},"enum"),", and\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed#27-error"},"error"),"."),(0,i.kt)("p",null,"Complex values have an implied type when their constituent values all have\nimplied types."),(0,i.kt)("h4",{id:"241-record-value"},"2.4.1 Record Value"),(0,i.kt)("p",null,"A record value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{ <name> : <value>, <name> : <value>, ... }\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<name>")," is a ",(0,i.kt)("a",{parentName:"p",href:"#21-names"},"ZSON name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<value>")," is\nany optionally-decorated ZSON value inclusive of other records.\nEach name/value pair is called a ",(0,i.kt)("em",{parentName:"p"},"field"),".\nThere may be zero or more fields."),(0,i.kt)("h4",{id:"242-array-value"},"2.4.2 Array Value"),(0,i.kt)("p",null,"An array value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[ <value>, <value>, ... ]\n")),(0,i.kt)("p",null,"If the elements of the array are not of uniform type, then the implied type of\nthe array elements is a union of the types present."),(0,i.kt)("p",null,"An array value may be empty.  An empty array value without a type decorator is\npresumed to be an empty array of type ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,i.kt)("h4",{id:"243-set-value"},"2.4.3 Set Value"),(0,i.kt)("p",null,"A set value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"|[ <value>, <value>, ... ]|\n")),(0,i.kt)("p",null,"where the indicated values must be distinct."),(0,i.kt)("p",null,"If the elements of the set are not of uniform type, then the implied type of\nthe set elements is a union of the types present."),(0,i.kt)("p",null,"A set value may be empty.  An empty set value without a type decorator is\npresumed to be an empty set of type ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,i.kt)("h4",{id:"244-map-value"},"2.4.4 Map Value"),(0,i.kt)("p",null,"A map value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"|{ <key> : <value>, <key> : <value>, ... }|\n")),(0,i.kt)("p",null,"where zero or more comma-separated, key/value pairs are present."),(0,i.kt)("p",null,"Whitespace around keys and values is generally optional, but to\navoid ambiguity, whitespace must separate an IPv6 key from the colon\nthat follows it."),(0,i.kt)("p",null,"An empty map value without a type decorator is\npresumed to be an empty map of type ",(0,i.kt)("inlineCode",{parentName:"p"},"|{null: null}|"),"."),(0,i.kt)("h4",{id:"245-union-value"},"2.4.5 Union Value"),(0,i.kt)("p",null,"A union value is a value that conforms to one of the types within a union type.\nIf the value appears in a context in which the type is unknown or ambiguous,\nthen the value must be decorated as ",(0,i.kt)("a",{parentName:"p",href:"#22-type-decorators"},"described above"),"."),(0,i.kt)("h4",{id:"246-enum-value"},"2.4.6 Enum Value"),(0,i.kt)("p",null,"An enum type represents a symbol from a finite set of symbols\nreferenced by name."),(0,i.kt)("p",null,"An enum value is indicated with the sigil ",(0,i.kt)("inlineCode",{parentName:"p"},"%")," and has the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"%<name>\n")),(0,i.kt)("p",null,"where the ",(0,i.kt)("inlineCode",{parentName:"p"},"<name>")," is ",(0,i.kt)("a",{parentName:"p",href:"#21-names"},"ZSON name"),"."),(0,i.kt)("p",null,"An enum value must appear in a context where the enum type is known, i.e.,\nwith an explicit enum type decorator or within a complex type where the\ncontained enum type is defined by the complex type's decorator."),(0,i.kt)("p",null,"A sequence of enum values might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"%HEADS (flip=(enum(HEADS,TAILS)))\n%TAILS (flip)\n%HEADS (flip)\n")),(0,i.kt)("h4",{id:"247-error-value"},"2.4.7 Error Value"),(0,i.kt)("p",null,"An error value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"error(<value>)\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<value>")," is any ZSON value."),(0,i.kt)("h3",{id:"25-types"},"2.5 Types"),(0,i.kt)("p",null,"A primitive type is simply the name of the primitive type, i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"uint16"),", etc.  Complex types are defined as follows."),(0,i.kt)("h4",{id:"251-record-type"},"2.5.1 Record Type"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"record type")," has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{ <name> : <type>, <name> : <type>, ... }\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<name>")," is a ",(0,i.kt)("a",{parentName:"p",href:"#21-names"},"ZSON name")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"<type>")," is any type."),(0,i.kt)("p",null,"The order of the record fields is significant,\ne.g., type ",(0,i.kt)("inlineCode",{parentName:"p"},"{a:int32,b:int32}")," is distinct from type ",(0,i.kt)("inlineCode",{parentName:"p"},"{b:int32,a:int32}"),"."),(0,i.kt)("h4",{id:"252-array-type"},"2.5.2 Array Type"),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"array type")," has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"[ <type> ]\n")),(0,i.kt)("h4",{id:"253-set-type"},"2.5.3 Set Type"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"set type")," has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"|[ <type> ]|\n")),(0,i.kt)("h4",{id:"254-map-type"},"2.5.4 Map Type"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"map type")," has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"|{ <key-type>: <value-type> }|\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<key-type>")," is the type of the keys and ",(0,i.kt)("inlineCode",{parentName:"p"},"<value-type>")," is the\ntype of the values."),(0,i.kt)("h4",{id:"255-union-type"},"2.5.5 Union Type"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"union type")," has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"( <type>, <type>, ... )\n")),(0,i.kt)("p",null,"where there are at least two types in the list."),(0,i.kt)("h4",{id:"256-enum-type"},"2.5.6 Enum Type"),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"enum type")," has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"enum( <name>, <name>, ... )\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<name>")," is a ",(0,i.kt)("a",{parentName:"p",href:"#21-names"},"ZSON name"),".\nEach enum name must be unique and the order is not significant, e.g.,\nenum type ",(0,i.kt)("inlineCode",{parentName:"p"},"enum(HEADS,TAILS)")," is equal to type ",(0,i.kt)("inlineCode",{parentName:"p"},"enum(TAILS,HEADS)"),"."),(0,i.kt)("h4",{id:"257-error-type"},"2.5.7 Error Type"),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"error type")," has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"error( <type> )\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<type>")," is the type of the underlying ZSON values wrapped as an error."),(0,i.kt)("h4",{id:"258-named-type"},"2.5.8 Named Type"),(0,i.kt)("p",null,"A named type has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<name> = ( <type> )\n")),(0,i.kt)("p",null,"where a new type is defined with the given name and type."),(0,i.kt)("p",null,"When a named type appears in a complex value, the new type name may be\nreferenced by any subsequent value in left-to-right depth-first order."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{p1:80 (port=(uint16)), p2: 8080 (port)}\n")),(0,i.kt)("p",null,"is valid but"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{p1:80 port, p2: 8080 (port=(uint16))}\n")),(0,i.kt)("p",null,"is invalid."),(0,i.kt)("p",null,"Named types may be redefined, in which case subsequent references\nresolve to the most recent definition according to"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"sequence order across values, or"),(0,i.kt)("li",{parentName:"ul"},"left-to-right depth-first order within a complex value.")),(0,i.kt)("h3",{id:"26-null-value"},"2.6 Null Value"),(0,i.kt)("p",null,"The null value is represented by the string ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,i.kt)("p",null,"A value of any type can be null.  It is up to an\nimplementation to decide how external data structures map into and\nout of null values of different types.  Typically, a null value means either the\nzero value or, in the case of record fields, an optional field whose\nvalue is not present, though these semantics are not explicitly\ndefined by ZSON."),(0,i.kt)("h2",{id:"3-examples"},"3. Examples"),(0,i.kt)("p",null,"The simplest ZSON value is a single value, perhaps a string like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"hello, world"\n')),(0,i.kt)("p",null,"There's no need for a type declaration here.  It's explicitly a string."),(0,i.kt)("p",null,"A relational table might look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{ city: "Berkeley", state: "CA", population: 121643 (uint32) } (=city_schema)\n{ city: "Broad Cove", state: "ME", population: 806 (uint32) } (=city_schema)\n{ city: "Baton Rouge", state: "LA", population: 221599 (uint32) } (=city_schema)\n')),(0,i.kt)("p",null,"This ZSON text here depicts three record values.  It defines a type called ",(0,i.kt)("inlineCode",{parentName:"p"},"city_schema"),"\nand the inferred type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"city_schema")," has the signature:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{ city:string, state:string, population:uint32 }\n")),(0,i.kt)("p",null,"When all the values in a sequence have the same record type, the sequence\ncan be interpreted as a ",(0,i.kt)("em",{parentName:"p"},"table"),", where the ZSON record values form the ",(0,i.kt)("em",{parentName:"p"},"rows"),"\nand the fields of the records form the ",(0,i.kt)("em",{parentName:"p"},"columns"),".  In this way, these\nthree records form a relational table conforming to the schema ",(0,i.kt)("inlineCode",{parentName:"p"},"city_schema"),"."),(0,i.kt)("p",null,"In contrast, a ZSON text representing a semi-structured sequence of log lines\nmight look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{\n    info: "Connection Example",\n    src: { addr: 10.1.1.2, port: 80 (uint16) } (=socket),\n    dst: { addr: 10.0.1.2, port: 20130 (uint16) } (=socket)\n} (=conn)\n{\n    info: "Connection Example 2",\n    src: { addr: 10.1.1.8, port: 80 (uint16) } (=socket),\n    dst: { addr: 10.1.2.88, port: 19801 (uint16) } (=socket)\n} (=conn)\n{\n    info: "Access List Example",\n    nets: [ 10.1.1.0/24, 10.1.2.0/24 ]\n} (=access_list)\n{ metric: "A", ts: 2020-11-24T08:44:09.586441-08:00, value: 120 }\n{ metric: "B", ts: 2020-11-24T08:44:20.726057-08:00, value: 0.86 }\n{ metric: "A", ts: 2020-11-24T08:44:32.201458-08:00, value: 126 }\n{ metric: "C", ts: 2020-11-24T08:44:43.547506-08:00, value: { x:10, y:101 } }\n')),(0,i.kt)("p",null,"In this case, the first record defines not just a record type\nwith named type ",(0,i.kt)("inlineCode",{parentName:"p"},"conn"),", but also a second embedded record type called ",(0,i.kt)("inlineCode",{parentName:"p"},"socket"),".\nThe parenthesized decorators are used where a type is not inferred from\nthe value itself:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"socket")," is a record with typed fields ",(0,i.kt)("inlineCode",{parentName:"li"},"addr")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"port")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"port")," is an unsigned 16-bit integer, and"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"conn")," is a record with typed fields ",(0,i.kt)("inlineCode",{parentName:"li"},"info"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"src"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"dst"),".")),(0,i.kt)("p",null,"The subsequent value defines a type called ",(0,i.kt)("inlineCode",{parentName:"p"},"access_list"),".  In this case,\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"nets")," field is an array of networks and illustrates the helpful range of\nprimitive types in ZSON.  Note that the syntax here implies\nthe type of the array, as it is inferred from the type of the elements."),(0,i.kt)("p",null,"Finally, there are four more values that show ZSON's efficacy for\nrepresenting metrics.  Here, there are no type decorators as all of the field\ntypes are implied by their syntax, and hence, the top-level record type is implied.\nFor instance, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ts")," field is an RFC 3339 date and time string,\nunambiguously the primitive type ",(0,i.kt)("inlineCode",{parentName:"p"},"time"),".  Further,\nnote that the ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," field takes on different types and even a complex record\ntype on the last line.  In this case, there is a different top-level\nrecord type implied by each of the three variations of type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," field."),(0,i.kt)("h2",{id:"4-grammar"},"4. Grammar"),(0,i.kt)("p",null,"Here is a left-recursive pseudo-grammar of ZSON.  Note that not all\nacceptable inputs are semantically valid as type mismatches may arise.\nFor example, union and enum values must both appear in a context\nthat defines their type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'<zson> = <zson> <eos> <dec-value> | <zson> <dec-value> | <dec-value>\n\n<eos> = .\n\n<value> = <any> | <any> <val-typedef> | <any> <decorators>\n\n<val-typedef> = "(" "=" <name> ")"\n\n<decorators> = "(" <type> ")" | <decorators> "(" <type> ")"\n\n<any> = <primitive> | <type-val> | <record> | <array> | <set> | <map> | <enum>\n\n<primitive> = primitive value as defined above\n\n<record> = "{" <flist> "}"  |  "{"  "}"\n\n<flist> = <flist> "," <field> | <field>\n\n<field> = <name> ":" <value>\n\n<name> = <identifier> | <quoted-string>\n\n<quoted-string> = quoted string as defined above\n\n<identifier> = as defined above\n\n<array> = "[" <vlist> "]"  |  "["  "]"\n\n<vlist> = <vlist> "," <value> | <value>\n\n<set> = "|[" <vlist> "]|"  |  "|["  "]|"\n\n<enum> = "%" ( <name> | <quoted-string> )\n\n<map> = "|{" <mlist> "}|"  |  "|{"  "}|"\n\n<mlist> = <mvalue> | <mlist> "," <mvalue>\n\n<mvalue> = <value> ":" <value>\n\n<type-value> = "<" <type> ">"\n\n<error-value> = "error(" <value> ")"\n\n<type> = <primitive-type> | <record-type> | <array-type> | <set-type> |\n            <union-type> | <enum-type> | <map-type> |\n            <type-def> | <name> | <numeric> | <error-type>\n\n<primitive-type> = uint8 | uint16 | etc. as defined above\n\n<record-type> = "{" <tflist> "}"  |  "{" "}"\n\n<tflist> = <tflist> "," <tfield> | <tfield>\n\n<tfield> = <name> ":" <type>\n\n<array-type> = "[" <type> "]"  |  "[" "]"\n\n<set-type> = "|[" <type> "]|"  |  "|[" "]|"\n\n<union-type> = "(" <type> "," <tlist> ")"\n\n<tlist> = <tlist> "," <type> | <type>\n\n<enum-type> = "enum(" <nlist> ")"\n\n<nlist> = <nlist> "," <name> | <name>\n\n<map-type> = "{" <type> "," <type> "}"\n\n<type-def> = <identifier> = <type-type>\n\n<name> = as defined above\n\n<numeric> = [0-9]+\n\n<error-type> = "error(" <type> ")"\n')))}k.isMDXComponent=!0}}]);