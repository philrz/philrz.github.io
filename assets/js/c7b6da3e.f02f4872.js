"use strict";(self.webpackChunkzed_docs=self.webpackChunkzed_docs||[]).push([[5352],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return c}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),u=p(n),c=r,h=u["".concat(d,".").concat(c)]||u[c]||m[c]||i;return n?a.createElement(h,l(l({ref:t},s),{},{components:n})):a.createElement(h,l({ref:t},s))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1778:function(e,t,n){n.r(t),n.d(t,{assets:function(){return s},contentTitle:function(){return d},default:function(){return c},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return m}});var a=n(3117),r=n(102),i=(n(7294),n(3905)),l=["components"],o={sidebar_position:1,sidebar_label:"ZNG"},d="ZNG Specification",p={unversionedId:"formats/zng",id:"version-v1.2.0/formats/zng",title:"ZNG Specification",description:"1. Introduction",source:"@site/versioned_docs/version-v1.2.0/formats/zng.md",sourceDirName:"formats",slug:"/formats/zng",permalink:"/docs/formats/zng",draft:!1,editUrl:"https://github.com/brimdata/zed/edit/main/docs/formats/zng.md",tags:[],version:"v1.2.0",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"ZNG"},sidebar:"tutorialSidebar",previous:{title:"Data Model",permalink:"/docs/formats/zed"},next:{title:"ZSON",permalink:"/docs/formats/zson"}},s={},m=[{value:"1. Introduction",id:"1-introduction",level:2},{value:"2. The ZNG Format",id:"2-the-zng-format",level:2},{value:"2.1 Types Frame",id:"21-types-frame",level:3},{value:"2.1.1 Record Typedef",id:"211-record-typedef",level:4},{value:"2.1.2 Array Typedef",id:"212-array-typedef",level:4},{value:"2.1.3 Set Typedef",id:"213-set-typedef",level:4},{value:"2.1.4 Map Typedef",id:"214-map-typedef",level:4},{value:"2.1.5 Union Typedef",id:"215-union-typedef",level:4},{value:"2.1.6 Enum Typedef",id:"216-enum-typedef",level:4},{value:"2.1.7 Error Typedef",id:"217-error-typedef",level:4},{value:"2.1.8 Named Type Typedef",id:"218-named-type-typedef",level:4},{value:"2.2 Values Frame",id:"22-values-frame",level:3},{value:"2.2.1 Tag-Encoding of Values",id:"221-tag-encoding-of-values",level:4},{value:"2.2.2 Tag-Encoded Body of Primitive Values",id:"222-tag-encoded-body-of-primitive-values",level:4},{value:"2.2.3 Tag-Encoded Body of Complex Values",id:"223-tag-encoded-body-of-complex-values",level:4},{value:"2.3 Control Frame",id:"23-control-frame",level:3},{value:"2.4 End of Stream",id:"24-end-of-stream",level:3},{value:"3. Primitive Types",id:"3-primitive-types",level:2},{value:"4. Type Values",id:"4-type-values",level:2},{value:"4.1 Record Type Value",id:"41-record-type-value",level:4},{value:"4.2 Array Type Value",id:"42-array-type-value",level:4},{value:"4.3 Set Type Value",id:"43-set-type-value",level:4},{value:"4.4 Map Type Value",id:"44-map-type-value",level:4},{value:"4.5 Union Type Value",id:"45-union-type-value",level:4},{value:"4.6 Enum Type Value",id:"46-enum-type-value",level:4},{value:"4.7 Error Type Value",id:"47-error-type-value",level:4},{value:"4.8 Named Type Type Value",id:"48-named-type-type-value",level:4}],u={toc:m};function c(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"zng-specification"},"ZNG Specification"),(0,i.kt)("h2",{id:"1-introduction"},"1. Introduction"),(0,i.kt)("p",null,'ZNG (pronounced "zing") is an efficient, sequence-oriented serialization format for any data\nconforming to the ',(0,i.kt)("a",{parentName:"p",href:"/docs/formats/zed"},"Zed data model"),"."),(0,i.kt)("p",null,'ZNG is "row oriented" and\nanalogous to ',(0,i.kt)("a",{parentName:"p",href:"https://avro.apache.org"},"Apache Avro")," but does not\nrequire schema definitions as it instead utilizes the fine-grained type system\nof the Zed data model.\nThis binary format is based on machine-readable data types with an\nencoding methodology inspired by Avro,\n",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Apache_Parquet"},"Parquet"),", and\n",(0,i.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers"},"Protocol Buffers"),"."),(0,i.kt)("p",null,'To this end, ZNG embeds all type information\nin the stream itself while having a binary serialization format that\nallows "lazy parsing" of fields such that\nonly the fields of interest in a stream need to be deserialized and interpreted.\nUnlike Avro, ZNG embeds its "schemas" in the data stream as Zed types and thereby admits\nan efficient multiplexing of heterogeneous data types by prepending to each\ndata value a simple integer identifier to reference its type.'),(0,i.kt)("p",null,'Since no external schema definitions exist in ZNG, a "type context" is constructed\non the fly by composing dynamic type definitions embedded in the ZNG format.\nZNG can be readily adapted to systems like\n',(0,i.kt)("a",{parentName:"p",href:"https://kafka.apache.org/"},"Apache Kafka")," which utilize schema registries,\nby having a connector translate the schemas implied in the\nZNG stream into registered schemas and vice versa.  Better still, Kafka could\nbe used natively with ZNG obviating the need for the schema registry."),(0,i.kt)("p",null,"Multiple ZNG streams with different type contexts are easily merged because the\nserialization of values does not depend on the details of\nthe type context.  One or more streams can be merged by simply merging the\ninput contexts into an output context and adjusting the type reference of\neach value in the output ZNG sequence.  The values need not be traversed\nor otherwise rewritten to be merged in this fashion."),(0,i.kt)("h2",{id:"2-the-zng-format"},"2. The ZNG Format"),(0,i.kt)("p",null,"A ZNG stream comprises a sequence of frames where\neach frame contains one of three types of data:\n",(0,i.kt)("em",{parentName:"p"},"types"),", ",(0,i.kt)("em",{parentName:"p"},"values"),", or externally-defined ",(0,i.kt)("em",{parentName:"p"},"control"),"."),(0,i.kt)("p",null,"A stream is punctuated by the end-of-stream value ",(0,i.kt)("inlineCode",{parentName:"p"},"0xff"),"."),(0,i.kt)("p",null,"Each frame header includes a length field\nallowing an implementation to easily skip from frame to frame."),(0,i.kt)("p",null,'Each frame begins with a single-byte "frame code":'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    7 6 5 4 3 2 1 0\n   +-+-+-+-+-+-+-+-+\n   |V|C|  T|      L|\n   +-+-+-+-+-+-+-+-+\n\n   V: 1 bit\n\n     Version number.  Must be zero.\n\n   C: 1 bit\n\n     Indicates compressed frame data.\n\n   T: 2 bits\n\n     Type of frame data.\n\n       00: Types\n       01: Values\n       10: Control\n       11: End of stream\n\n   L: 4 bits\n\n     Low-order bits of frame length.\n")),(0,i.kt)("p",null,"Bit 7 of the frame code must be zero as it defines version 0\nof the ZNG stream format.  If a future version of ZNG\narises, bit 7 of future ZNG frames will be 1.\nZNG version 0 readers must ignore and skip over such frames using the\n",(0,i.kt)("inlineCode",{parentName:"p"},"len")," field, which must survive future versions.\nAny future versions of ZNG must be able to integrate version 0 frames\nfor backward compatibility."),(0,i.kt)("p",null,'Following the frame code is its encoded length followed by a "frame payload"\nof bytes of said length:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<frame code><uvarint><frame payload>\n")),(0,i.kt)("p",null,"The length encoding utilizes a variable-length unsigned integer called herein a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Inspired by Protocol Buffers,\na ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint")," is an unsigned, variable-length integer encoded as a sequence of\nbytes consisting of N-1 bytes with bit 7 clear and the Nth byte with bit 7 set,\nwhose value is the base-128 number composed of the digits defined by the lower\n7 bits of each byte from least-significant digit (byte 0) to\nmost-significant digit (byte N-1).")),(0,i.kt)("p",null,"The frame payload's length is equal to the value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint")," following the\nframe code times 16 plus the low 4-bit integer value ",(0,i.kt)("inlineCode",{parentName:"p"},"L")," field in the frame code."),(0,i.kt)("p",null,"If the ",(0,i.kt)("inlineCode",{parentName:"p"},"C")," bit is set in the frame code, then the frame payload following the\nframe length is compressed and has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<format><size><compressed payload>\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<format>")," is a single byte indicating the compression format of the the compressed payload,"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<size>")," is a ",(0,i.kt)("inlineCode",{parentName:"li"},"uvarint")," encoding the size of the uncompressed payload, and"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<compressed payload>")," is a bytes sequence whose length equals\nthe outer frame length less 1 byte for the compression format and the encoded length\nof the ",(0,i.kt)("inlineCode",{parentName:"li"},"uvarint")," size field.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"compressed payload")," is compressed according to the compression algorithm\nspecified by the ",(0,i.kt)("inlineCode",{parentName:"p"},"format")," byte.  Each frame is compressed independently\nsuch that the compression algorithm's state is not carried from frame to frame\n(thereby enabling parallel decoding)."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"<size>")," value is redundant with the compressed payload\nbut is useful to an implementation to deterministically\nsize decompression buffers in advance of decoding."),(0,i.kt)("p",null,"Values for the ",(0,i.kt)("inlineCode",{parentName:"p"},"format")," byte are defined in the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/formats/compression"},"ZNG compression format specification"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This arrangement of frames separating types and values allows\nfor efficient scanning and parallelization.  In general, values depend\non type definitions but as long as all of the types are known when\nvalues are used, decoding can be done in parallel.  Likewise, since\neach block is independently compressed, the blocks can be decompressed\nin parallel.  Moreover, efficient filtering can be carried out over\nuncompressed data before it is deserialized into native data structures,\ne.g., allowing entire frames to be discarded based on\nheuristics, e.g., knowing a filtering predicate can't be true based on a\nquick scan of the data perhaps using the Boyer-Moore algorithm to determine\nthat a comparison with a string constant would not work for any\nvalue in the buffer.")),(0,i.kt)("p",null,"Whether the payload was originally uncompressed or was decompressed, it is\nthen interpreted according to the ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," bits of the frame code as a"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#21-types-frame"},"types frame"),","),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#22-values-frame"},"values frame"),", or"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#23-control-frame"},"control frame"),".")),(0,i.kt)("h3",{id:"21-types-frame"},"2.1 Types Frame"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"types frame"),' encodes a sequence of type definitions for complex Zed types\nand establishes a "type ID" for each such definition.\nType IDs for the "primitive types"\nare predefined with the IDs listed in the ',(0,i.kt)("a",{parentName:"p",href:"#3-primitive-types"},"Primitive Types")," table."),(0,i.kt)("p",null,'Each definition, or "typedef",\nconsists of a typedef code followed by its type-specific encoding as described below.\nEach type must be decoded in sequence to find the start of the next type definition\nas there is no framing to separate the typedefs.'),(0,i.kt)("p",null,"The typedefs are numbered in the order encountered starting at 30\n(as the largest primary type ID is 29).  Types refer to other types\nby their type ID.  Note that the type ID of a typedef is implied by its\nposition in the sequence and is not explicitly encoded."),(0,i.kt)("p",null,"The typedef codes are defined as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Code"),(0,i.kt)("th",{parentName:"tr",align:null},"Complex Type"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"record type definition")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"array type definition")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"set type definition")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"3"),(0,i.kt)("td",{parentName:"tr",align:null},"map type definition")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"4"),(0,i.kt)("td",{parentName:"tr",align:null},"union type definition")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"5"),(0,i.kt)("td",{parentName:"tr",align:null},"enum type definition")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"6"),(0,i.kt)("td",{parentName:"tr",align:null},"error type definition")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"7"),(0,i.kt)("td",{parentName:"tr",align:null},"named type definition")))),(0,i.kt)("p",null,"Any references to a type ID in the body of a typedef are encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),","),(0,i.kt)("h4",{id:"211-record-typedef"},"2.1.1 Record Typedef"),(0,i.kt)("p",null,"A record typedef creates a new type ID equal to the next stream type ID\nwith the following structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"---------------------------------------------------------\n|0x00|<ncolumns>|<name1><type-id-1><name2><type-id-2>...|\n---------------------------------------------------------\n")),(0,i.kt)("p",null,"Record types consist of an ordered set of columns where each column consists of\na name and its type.  Unlike JSON, the ordering of the columns is significant\nand must be preserved through any APIs that consume, process, and emit ZNG records."),(0,i.kt)("p",null,"A record type is encoded as a count of fields, i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"<ncolumns>")," from above,\nfollowed by the field definitions,\nwhere a field definition is a field name followed by a type ID, i.e.,\n",(0,i.kt)("inlineCode",{parentName:"p"},"<name1>")," followed by ",(0,i.kt)("inlineCode",{parentName:"p"},"<type-id-1>")," etc. as indicated above."),(0,i.kt)("p",null,"The field names in a record must be unique."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"<ncolumns>")," value is encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),"."),(0,i.kt)("p",null,'The field name is encoded as a UTF-8 string defining a "ZNG identifier".\nThe UTF-8 string\nis further encoded as a "counted string", which is the ',(0,i.kt)("inlineCode",{parentName:"p"},"uvarint")," encoding\nof the length of the string followed by that many bytes of UTF-8 encoded\nstring data."),(0,i.kt)("p",null,"N.B.: As defined by ",(0,i.kt)("a",{parentName:"p",href:"/docs/formats/zson"},"ZSON"),", a field name can be any valid UTF-8 string much like JSON\nobjects can be indexed with arbitrary string keys (via index operator)\neven if the field names available to the dot operator are restricted\nby language syntax for identifiers."),(0,i.kt)("p",null,"The type ID follows the field name and is encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),"."),(0,i.kt)("h4",{id:"212-array-typedef"},"2.1.2 Array Typedef"),(0,i.kt)("p",null,"An array type is encoded as simply the type code of the elements of\nthe array encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"----------------\n|0x01|<type-id>|\n----------------\n")),(0,i.kt)("h4",{id:"213-set-typedef"},"2.1.3 Set Typedef"),(0,i.kt)("p",null,"A set type is encoded as the type ID of the\nelements of the set, encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"----------------\n|0x02|<type-id>|\n----------------\n")),(0,i.kt)("h4",{id:"214-map-typedef"},"2.1.4 Map Typedef"),(0,i.kt)("p",null,"A map type is encoded as the type code of the key\nfollowed by the type code of the value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"--------------------------\n|0x03|<type-id>|<type-id>|\n--------------------------\n")),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"<type-id>")," is encoded as ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),"."),(0,i.kt)("h4",{id:"215-union-typedef"},"2.1.5 Union Typedef"),(0,i.kt)("p",null,"A union typedef creates a new type ID equal to the next stream type ID\nwith the following structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"-----------------------------------------\n|0x04|<ntypes>|<type-id-1><type-id-2>...|\n-----------------------------------------\n")),(0,i.kt)("p",null,"A union type consists of an ordered set of types\nencoded as a count of the number of types, i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"<ntypes>")," from above,\nfollowed by the type IDs comprising the types of the union.\nThe type IDs of a union must be unique."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"<ntypes>")," and the type IDs are all encoded as ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"<ntypes>")," cannot be 0."),(0,i.kt)("h4",{id:"216-enum-typedef"},"2.1.6 Enum Typedef"),(0,i.kt)("p",null,"An enum type is encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint")," representing the number of symbols\nin the enumeration followed by the names of each symbol."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"--------------------------------\n|0x05|<nelem>|<name1><name2>...|\n--------------------------------\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"<nelem>")," is encoded as ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),".\nThe names have the same UTF-8 format as record field names and are encoded\nas counted strings following the same convention as record field names."),(0,i.kt)("h4",{id:"217-error-typedef"},"2.1.7 Error Typedef"),(0,i.kt)("p",null,"An error type is encoded as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"----------------\n|0x06|<type-id>|\n----------------\n")),(0,i.kt)("p",null,"which defines a new error type for error values that have the underlying type\nindicated by ",(0,i.kt)("inlineCode",{parentName:"p"},"<type-id>"),"."),(0,i.kt)("h4",{id:"218-named-type-typedef"},"2.1.8 Named Type Typedef"),(0,i.kt)("p",null,"A named type defines a new type ID that binds a name to a previously existing type ID.  "),(0,i.kt)("p",null,"A named type is encoded as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"----------------------\n|0x07|<name><type-id>|\n----------------------\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<name>")," is an identifier representing the new type name with a new type ID\nallocated as the next available type ID in the stream that refers to the\nexisting type ID ",(0,i.kt)("inlineCode",{parentName:"p"},"<type-id>"),".  ",(0,i.kt)("inlineCode",{parentName:"p"},"<type-id>")," is encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<name>"),"\nis encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint")," representing the length of the name in bytes,\nfollowed by that many bytes of UTF-8 string."),(0,i.kt)("p",null,"As indicated in the ",(0,i.kt)("a",{parentName:"p",href:"/docs/formats/zed"},"data model"),",\nit is an error to define a type name that has the same name as a primitive type,\nand it is permissible to redefine a previously defined type name with a\ntype that differs from the previous definition."),(0,i.kt)("h3",{id:"22-values-frame"},"2.2 Values Frame"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"values frame")," is a sequence of Zed values each encoded as the value's type ID,\nencoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),", followed by its tag-encoded serialization as described below."),(0,i.kt)("p",null,"Since a single type ID encodes the entire value's structure, no additional\ntype information is needed.  Also, the value encoding follows the structure\nof the type explicitly so the type is not needed to parse the structure of the\nvalue, but rather only its semantics."),(0,i.kt)("p",null,"It is an error for a value to reference a type ID that has not been\npreviously defined by a typedef scoped to the stream in which the value\nappears."),(0,i.kt)("p",null,'The value is encoded using a "tag-encoding" scheme\nthat captures the structure of both primitive types and the recursive\nnature of complex types.  This structure is encoded\nexplicitly in every value and the boundaries of each value and its\nrecursive nesting can be parsed without knowledge of the type or types of\nthe underlying values.  This admits an efficient implementation\nfor traversing the values, inclusive of recursive traversal of complex values,\nwhereby the inner loop need not consult and interpret the type ID of each element.'),(0,i.kt)("h4",{id:"221-tag-encoding-of-values"},"2.2.1 Tag-Encoding of Values"),(0,i.kt)("p",null,'Each value is prefixed with a "tag" that defines:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"whether it is the null value, and"),(0,i.kt)("li",{parentName:"ul"},"its encoded length in bytes.")),(0,i.kt)("p",null,"The tag is 0 for the null value and ",(0,i.kt)("inlineCode",{parentName:"p"},"length+1")," for non-null values where\n",(0,i.kt)("inlineCode",{parentName:"p"},"length")," is the encoded length of the value.  Note that this encoding\ndifferentiates between a null value and a zero-length value.  Many data types\nhave a meaningful interpretation of a zero-length value, for example, an\nempty array, the empty record, etc."),(0,i.kt)("p",null,"The tag itself is encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),"."),(0,i.kt)("h4",{id:"222-tag-encoded-body-of-primitive-values"},"2.2.2 Tag-Encoded Body of Primitive Values"),(0,i.kt)("p",null,"Following the tag encoding is the value encoded in N bytes as described above.\nA typed value with a ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," of length ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," is interpreted as described in the\n",(0,i.kt)("a",{parentName:"p",href:"#3-primitive-types"},"Primitive Types")," table.  The type information needed to\ninterpret all of the value elements of a complex type are all implied by the\ntop-level type ID of the values frame.  For example, the type ID could indicate\na particular record type, which recursively provides the type information\nfor all of the elements within that record, including other complex types\nembedded within the top-level record."),(0,i.kt)("p",null,"Note that because the tag indicates the length of the value, there is no need\nto use varint encoding of integer values.  Instead, an integer value is encoded\nusing the full 8 bits of each byte in little-endian order.  Signed values,\nbefore encoding, are shifted left one bit, and the sign bit stored as bit 0.\nFor negative numbers, the remaining bits are negated so that the upper bytes\ntend to be zero-filled for small integers."),(0,i.kt)("h4",{id:"223-tag-encoded-body-of-complex-values"},"2.2.3 Tag-Encoded Body of Complex Values"),(0,i.kt)("p",null,"The body of a length-N container comprises zero or more tag-encoded values,\nwhere the values are encoded as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Value"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"array")),(0,i.kt)("td",{parentName:"tr",align:null},"concatenation of elements")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"set")),(0,i.kt)("td",{parentName:"tr",align:null},"normalized concatenation of elements")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"record")),(0,i.kt)("td",{parentName:"tr",align:null},"concatenation of elements")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"map")),(0,i.kt)("td",{parentName:"tr",align:null},"concatenation of key and value elements")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"union")),(0,i.kt)("td",{parentName:"tr",align:null},"concatenation of selector and value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"enum")),(0,i.kt)("td",{parentName:"tr",align:null},"position of enum element")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"error")),(0,i.kt)("td",{parentName:"tr",align:null},"wrapped element")))),(0,i.kt)("p",null,"Since N, the byte length of any of these container values, is known,\nthere is no need to encode a count of the\nelements present.  Also, since the type ID is implied by the typedef\nof any complex type, each value is encoded without its type ID."),(0,i.kt)("p",null,"For sets, the concatenation of elements must be normalized so that the\nsequence of bytes encoding each element's tag-counted value is\nlexicographically greater than that of the preceding element."),(0,i.kt)("p",null,"A union value is encoded as a container with two elements. The first\nelement, called the selector, is the ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint")," encoding of the\npositional index determining the type of the value in reference to the\nunion's list of defined types, and the second element is the value\nencoded according to that type."),(0,i.kt)("p",null,"An enumeration value is represented as the ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint")," encoding of the\npositional index of that value's symbol in reference to the enum's\nlist of defined symbols."),(0,i.kt)("p",null,"A map value is encoded as a container whose elements are alternating\ntag-encoded keys and values, with keys and values encoded according to\nthe map's key type and value type, respectively."),(0,i.kt)("p",null,"The concatenation of elements must be normalized so that the\nsequence of bytes encoding each tag-counted key (of the key/value pair) is\nlexicographically greater than that of the preceding key (of the preceding\nkey/value pair)."),(0,i.kt)("h3",{id:"23-control-frame"},"2.3 Control Frame"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"control frame")," contains an application-defined control message."),(0,i.kt)("p",null,"Control frames are available to higher-layer protocols and are carried\nin ZNG as a convenient signaling mechanism.  A ZNG implementation\nmay skip over all control frames and is guaranteed by\nthis specification to decode all of the data as described herein even if such\nframes provide additional semantics on top of the base ZNG format."),(0,i.kt)("p",null,"The body of a control frame is a control message and may be JSON,\nZSON, ZNG, binary, or UTF-8 text.  The serialization of the control\nframe body is independent of the ZNG stream containing the control\nframe."),(0,i.kt)("p",null,"Any control message not known by a ZNG data receiver shall be ignored."),(0,i.kt)("p",null,"The delivery order of control messages with respect to the delivery\norder of values of the ZNG stream should be preserved by an API implementing\nZNG serialization and deserialization.\nIn this way, system endpoints that communicate using ZNG can embed\nprotocol directives directly into the ZNG stream as control payloads\nin an order-preserving semantics rather than defining additional\nlayers of encapsulation and synchronization between such layers."),(0,i.kt)("p",null,"A control frame has the following form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"-------------------------\n|<encoding>|<len>|<body>|\n-------------------------\n")),(0,i.kt)("p",null,"where"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<encoding>")," is a single byte indicating whether the body is encoded\nas ZNG (0), JSON (1), ZSON (2), an arbitrary UTF-8 string (3), or arbitrary binary data (4),"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<len>")," is a ",(0,i.kt)("inlineCode",{parentName:"li"},"uvarint")," encoding the length in bytes of the body\n(exclusive of the length 1 encoding byte), and"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"<body>")," is a control message whose semantics are outside the scope of\nthe base ZNG specification.")),(0,i.kt)("p",null,"If the encoding type is ZNG, the embedded ZNG data\nstarts and ends a single ZNG stream independent of the outer ZNG stream."),(0,i.kt)("h3",{id:"24-end-of-stream"},"2.4 End of Stream"),(0,i.kt)("p",null,"A ZNG stream must be terminated by an end-of-stream marker.\nA new ZNG stream may begin immediately after an end-of-stream marker.\nEach such stream has its own, independent type context."),(0,i.kt)("p",null,"In this way, the concatenation of ZNG streams (or ZNG files containing\nZNG streams) results in a valid ZNG data sequence."),(0,i.kt)("p",null,"For example, a large ZNG file can be arranged into multiple, smaller streams\nto facilitate random access at stream boundaries.\nThis benefit comes at the cost of some additional overhead --\nthe space consumed by stream boundary markers and repeated type definitions.\nChoosing an appropriate stream size that balances this overhead with the\nbenefit of enabling random access is left up to implementations."),(0,i.kt)("p",null,"End-of-stream markers are also useful in the context of sending ZNG over Kafka,\nas a receiver can easily resynchronize with a live Kafka topic by\ndiscarding incomplete frames until a frame is found that is terminated\nby an end-of-stream marker (presuming the sender implementation aligns\nthe ZNG frames on Kafka message boundaries)."),(0,i.kt)("p",null,"A end-of-stream marker is encoded as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"------\n|0xff|\n------\n")),(0,i.kt)("p",null,'After this marker, all previously read\ntypedefs are invalidated and the "next available type ID" is reset to\nthe initial value of 30.  To represent subsequent values that use a\npreviously defined type, the appropriate typedef control code must\nbe re-emitted\n(and note that the typedef may now be assigned a different ID).'),(0,i.kt)("h2",{id:"3-primitive-types"},"3. Primitive Types"),(0,i.kt)("p",null,"For each ZNG primitive type, the following table describes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"its type ID, and"),(0,i.kt)("li",{parentName:"ul"},"the interpretation of a length ",(0,i.kt)("inlineCode",{parentName:"li"},"N")," ",(0,i.kt)("a",{parentName:"li",href:"#22-values-frame"},"value frame"),".")),(0,i.kt)("p",null,"All fixed-size multi-byte sequences representing machine words\nare serialized in little-endian format."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:"right"},"ID"),(0,i.kt)("th",{parentName:"tr",align:"center"},"N"),(0,i.kt)("th",{parentName:"tr",align:null},"ZNG Value Interpretation"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint8")),(0,i.kt)("td",{parentName:"tr",align:"right"},"0"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"unsigned int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint16")),(0,i.kt)("td",{parentName:"tr",align:"right"},"1"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"unsigned int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint32")),(0,i.kt)("td",{parentName:"tr",align:"right"},"2"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"unsigned int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint64")),(0,i.kt)("td",{parentName:"tr",align:"right"},"3"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"unsigned int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint128")),(0,i.kt)("td",{parentName:"tr",align:"right"},"4"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"unsigned int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"uint256")),(0,i.kt)("td",{parentName:"tr",align:"right"},"5"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"unsigned int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int8")),(0,i.kt)("td",{parentName:"tr",align:"right"},"6"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"signed int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int16")),(0,i.kt)("td",{parentName:"tr",align:"right"},"7"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"signed int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int32")),(0,i.kt)("td",{parentName:"tr",align:"right"},"8"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"signed int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int64")),(0,i.kt)("td",{parentName:"tr",align:"right"},"9"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"signed int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int128")),(0,i.kt)("td",{parentName:"tr",align:"right"},"10"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"signed int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"int256")),(0,i.kt)("td",{parentName:"tr",align:"right"},"11"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"signed int of length N")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"duration")),(0,i.kt)("td",{parentName:"tr",align:"right"},"12"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"signed int of length N as ns")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"time")),(0,i.kt)("td",{parentName:"tr",align:"right"},"13"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"signed int of length N as ns since epoch")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float16")),(0,i.kt)("td",{parentName:"tr",align:"right"},"14"),(0,i.kt)("td",{parentName:"tr",align:"center"},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"2 bytes of IEEE 64-bit format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float32")),(0,i.kt)("td",{parentName:"tr",align:"right"},"15"),(0,i.kt)("td",{parentName:"tr",align:"center"},"4"),(0,i.kt)("td",{parentName:"tr",align:null},"4 bytes of IEEE 64-bit format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float64")),(0,i.kt)("td",{parentName:"tr",align:"right"},"16"),(0,i.kt)("td",{parentName:"tr",align:"center"},"8"),(0,i.kt)("td",{parentName:"tr",align:null},"8 bytes of IEEE 64-bit format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float128")),(0,i.kt)("td",{parentName:"tr",align:"right"},"17"),(0,i.kt)("td",{parentName:"tr",align:"center"},"16"),(0,i.kt)("td",{parentName:"tr",align:null},"16 bytes of IEEE 64-bit format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"float256")),(0,i.kt)("td",{parentName:"tr",align:"right"},"18"),(0,i.kt)("td",{parentName:"tr",align:"center"},"32"),(0,i.kt)("td",{parentName:"tr",align:null},"32 bytes of IEEE 64-bit format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"decimal32")),(0,i.kt)("td",{parentName:"tr",align:"right"},"19"),(0,i.kt)("td",{parentName:"tr",align:"center"},"4"),(0,i.kt)("td",{parentName:"tr",align:null},"4 bytes of IEEE decimal format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"decimal64")),(0,i.kt)("td",{parentName:"tr",align:"right"},"20"),(0,i.kt)("td",{parentName:"tr",align:"center"},"8"),(0,i.kt)("td",{parentName:"tr",align:null},"8 bytes of IEEE decimal format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"decimal128")),(0,i.kt)("td",{parentName:"tr",align:"right"},"21"),(0,i.kt)("td",{parentName:"tr",align:"center"},"16"),(0,i.kt)("td",{parentName:"tr",align:null},"16 bytes of IEEE decimal format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"decimal256")),(0,i.kt)("td",{parentName:"tr",align:"right"},"22"),(0,i.kt)("td",{parentName:"tr",align:"center"},"32"),(0,i.kt)("td",{parentName:"tr",align:null},"32 bytes of IEEE decimal format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bool")),(0,i.kt)("td",{parentName:"tr",align:"right"},"23"),(0,i.kt)("td",{parentName:"tr",align:"center"},"1"),(0,i.kt)("td",{parentName:"tr",align:null},"one byte 0 (false) or 1 (true)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"bytes")),(0,i.kt)("td",{parentName:"tr",align:"right"},"24"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"N bytes of value")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:"right"},"25"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"UTF-8 byte sequence")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ip")),(0,i.kt)("td",{parentName:"tr",align:"right"},"26"),(0,i.kt)("td",{parentName:"tr",align:"center"},"4 or 16"),(0,i.kt)("td",{parentName:"tr",align:null},"4 or 16 bytes of IP address")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"net")),(0,i.kt)("td",{parentName:"tr",align:"right"},"27"),(0,i.kt)("td",{parentName:"tr",align:"center"},"8 or 32"),(0,i.kt)("td",{parentName:"tr",align:null},"8 or 32 bytes of IP prefix and subnet mask")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"type")),(0,i.kt)("td",{parentName:"tr",align:"right"},"28"),(0,i.kt)("td",{parentName:"tr",align:"center"},"variable"),(0,i.kt)("td",{parentName:"tr",align:null},"type value byte sequence ",(0,i.kt)("a",{parentName:"td",href:"#4-type-values"},"as defined below"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"null")),(0,i.kt)("td",{parentName:"tr",align:"right"},"29"),(0,i.kt)("td",{parentName:"tr",align:"center"},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"No value, always represents an undefined value")))),(0,i.kt)("h2",{id:"4-type-values"},"4. Type Values"),(0,i.kt)("p",null,"As the ZSON data model supports first-class types and because the ZNG design goals\nrequire that value serializations cannot change across type contexts, type values\nmust be encoded in a fashion that is independent of the type context.\nThus, a serialized type value encodes the entire type in a canonical form\naccording to the recursive definition in this section."),(0,i.kt)("p",null,"The type value of a primitive type (include type ",(0,i.kt)("inlineCode",{parentName:"p"},"type"),") is its primitive ID,\nserialized as a single byte."),(0,i.kt)("p",null,"The type value of a complex type is serialized recursively according to the\ncomplex type it represents as described below."),(0,i.kt)("h4",{id:"41-record-type-value"},"4.1 Record Type Value"),(0,i.kt)("p",null,"A record type value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"---------------------------------------------------\n|30|<ncolumns>|<name1><typeval><name2><typeval>...|\n---------------------------------------------------\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<ncolumns>")," is the number of columns in the record encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"<name1>")," etc. are the field names encoded as in the\nrecord typedef, and each ",(0,i.kt)("inlineCode",{parentName:"p"},"<typeval>")," is a recursive encoding of a type value."),(0,i.kt)("h4",{id:"42-array-type-value"},"4.2 Array Type Value"),(0,i.kt)("p",null,"An array type value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"--------------\n|31|<typeval>|\n--------------\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<typeval>")," is a recursive encoding of a type value."),(0,i.kt)("h4",{id:"43-set-type-value"},"4.3 Set Type Value"),(0,i.kt)("p",null,"An set type value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"--------------\n|32|<typeval>|\n--------------\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<typeval>")," is a recursive encoding of a type value."),(0,i.kt)("h4",{id:"44-map-type-value"},"4.4 Map Type Value"),(0,i.kt)("p",null,"A map type value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"--------------------------\n|33|<key-type>|<val-type>|\n--------------------------\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<key-type>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<val-type>")," are recursive encodings of type values."),(0,i.kt)("h4",{id:"45-union-type-value"},"4.5 Union Type Value"),(0,i.kt)("p",null,"A union type value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"-----------------------------------\n|34|<ntypes>|<typeval><typeval>...|\n-----------------------------------\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<ntypes>")," is the number of types in the union encoded as a ",(0,i.kt)("inlineCode",{parentName:"p"},"uvarint"),"\nand each ",(0,i.kt)("inlineCode",{parentName:"p"},"<typeval>")," is a recursive definition of a type value."),(0,i.kt)("h4",{id:"46-enum-type-value"},"4.6 Enum Type Value"),(0,i.kt)("p",null,"An enum type value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"------------------------------\n|35|<nelem>|<name1><name2>...|\n------------------------------\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<nelem>")," and each symbol name is encoded as in an enum typedef."),(0,i.kt)("h4",{id:"47-error-type-value"},"4.7 Error Type Value"),(0,i.kt)("p",null,"An error type value has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"-----------\n|36|<type>|\n-----------\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<type>")," is the type value of the error."),(0,i.kt)("h4",{id:"48-named-type-type-value"},"4.8 Named Type Type Value"),(0,i.kt)("p",null,"A named type type value may appear either as a definition or a reference.\nWhen a named type is referenced, it must have been previously\ndefined in the type value in accordance with a left-to-right depth-first-search (DFS)\ntraversal of the type."),(0,i.kt)("p",null,"A named type definition has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"--------------------\n|37|<name><typeval>|\n--------------------\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"<name>")," is encoded as in an named type typedef\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"<typeval>")," is a recursive encoding of a type value.  This creates\na binding between the given name and the indicated type value only within the\nscope of the encoded value and does not affect the type context.\nThis binding may be changed by another named type definition\nof the same name in the same type value according to the DFS order."),(0,i.kt)("p",null,"An named type reference has the form:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"-----------\n|38|<name>|\n-----------\n")),(0,i.kt)("p",null,"It is an error for an named type reference to appear in a type value with a name\nthat has not been previously defined according to the DFS order."))}c.isMDXComponent=!0}}]);