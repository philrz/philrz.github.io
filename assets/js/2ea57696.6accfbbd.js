"use strict";(self.webpackChunkzed_docs=self.webpackChunkzed_docs||[]).push([[1846],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return c}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,h=m["".concat(i,".").concat(c)]||m[c]||d[c]||s;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=m;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<s;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5501:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return i},default:function(){return c},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return d}});var a=n(7462),r=n(3366),s=(n(7294),n(3905)),o=["components"],l={sidebar_position:0,sidebar_label:"zq"},i="zq Tutorial",p={unversionedId:"tutorials/zq",id:"tutorials/zq",title:"zq Tutorial",description:"This tour provides new users of zq an overview of zq and",source:"@site/docs/tutorials/zq.md",sourceDirName:"tutorials",slug:"/tutorials/zq",permalink:"/docs/next/tutorials/zq",editUrl:"https://github.com/brimdata/zed/edit/main/docs/docs/tutorials/zq.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,sidebar_label:"zq"},sidebar:"tutorialSidebar",previous:{title:"Commands",permalink:"/docs/next/tutorials/"},next:{title:"zed",permalink:"/docs/next/tutorials/zed"}},u={},d=[{value:"But JSON",id:"but-json",level:2},{value:"<code>this</code> vs <code>.</code>",id:"this-vs-",level:2},{value:"Search vs Transformation",id:"search-vs-transformation",level:2},{value:"On to ZSON",id:"on-to-zson",level:2},{value:"Comprehensive Types",id:"comprehensive-types",level:2},{value:"Records",id:"records",level:2},{value:"Record Mutation",id:"record-mutation",level:2},{value:"Union Types",id:"union-types",level:2},{value:"First-class Types",id:"first-class-types",level:2},{value:"Sample",id:"sample",level:2},{value:"Fuse",id:"fuse",level:2},{value:"Real-world GitHub Data",id:"real-world-github-data",level:2},{value:"Data Discovery",id:"data-discovery",level:3},{value:"Cleaning up the Messy JSON",id:"cleaning-up-the-messy-json",level:3},{value:"Putting It All Together",id:"putting-it-all-together",level:2},{value:"Running Analytics",id:"running-analytics",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}],m={toc:d};function c(e){var t=e.components,n=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"zq-tutorial"},"zq Tutorial"),(0,s.kt)("p",null,"This tour provides new users of ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," an overview of ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," and\nthe ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/"},"Zed language"),"\nby walking through a number of examples on the command-line.\nThis should get you started without having to read through all the gory details\nof the ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/"},"Zed language")," or ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/commands/zq"},(0,s.kt)("inlineCode",{parentName:"a"},"zq")," command-line usage"),"."),(0,s.kt)("p",null,"We'll start with some simple one-liners on the command line where we feed\nsome data to ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," with ",(0,s.kt)("inlineCode",{parentName:"p"},"echo")," and specify ",(0,s.kt)("inlineCode",{parentName:"p"},"-")," for ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," input to indicate\nthat standard input should be used, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"echo '\"hello, world\"' | zq -\n")),(0,s.kt)("p",null,"Then, toward the end of the tour, we'll experiment with some real-world GitHub data\npulled from the GitHub API."),(0,s.kt)("p",null,"If you want to follow along on the command line,\njust make sure the ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," command ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/install"},"is installed"),"\nas well as ",(0,s.kt)("a",{parentName:"p",href:"https://stedolan.github.io/jq/"},(0,s.kt)("inlineCode",{parentName:"a"},"jq")),"."),(0,s.kt)("h2",{id:"but-json"},"But JSON"),(0,s.kt)("p",null,"While ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," is based on a new type of ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/formats/zed"},"data model called Zed"),",\nZed just so happens to be a superset of JSON."),(0,s.kt)("p",null,"So if all you ever use ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," for is manipulating JSON data,\nit can serve you well as a handy, go-to tool.  In this way, ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," is kind of\nlike ",(0,s.kt)("inlineCode",{parentName:"p"},"jq"),".  As you probably know, ",(0,s.kt)("inlineCode",{parentName:"p"},"jq"),"\nis a popular command-line tool for taking a sequence of JSON values as input,\ndoing interesting things on that input, and emitting results, of course, as JSON."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"jq")," is awesome and powerful, but its syntax and computational model can\nsometimes be daunting and difficult.  We tried to make ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," really easy and intuitive,\nand it is usually faster, sometimes ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/commands/zq#7-performance"},"much faster"),",\nthan ",(0,s.kt)("inlineCode",{parentName:"p"},"jq"),"."),(0,s.kt)("p",null,"To this end, if you want full JSON compatibility without having to delve into the\ndetails of Zed, just use the ",(0,s.kt)("inlineCode",{parentName:"p"},"-j")," option with ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," and this will tell ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," to\nexpect JSON input and produce JSON output."),(0,s.kt)("h2",{id:"this-vs-"},(0,s.kt)("inlineCode",{parentName:"h2"},"this")," vs ",(0,s.kt)("inlineCode",{parentName:"h2"},".")),(0,s.kt)("p",null,"For example, to add 1 to some numbers with ",(0,s.kt)("inlineCode",{parentName:"p"},"jq"),", you say:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"echo '1 2 3' | jq '.+1'\n")),(0,s.kt)("p",null,"and you get"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"2\n3\n4\n")),(0,s.kt)("p",null,"With ",(0,s.kt)("inlineCode",{parentName:"p"},"zq"),", the mysterious ",(0,s.kt)("inlineCode",{parentName:"p"},"jq")," value ",(0,s.kt)("inlineCode",{parentName:"p"},".")," is instead called\nthe almost-as-mysterious value\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/overview#23-the-special-value-this"},(0,s.kt)("inlineCode",{parentName:"a"},"this"))," and you say:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 2 3' | zq -z 'this+1' -\n")),(0,s.kt)("p",null,"which also gives"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"2\n3\n4\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note that we are using the ",(0,s.kt)("inlineCode",{parentName:"p"},"-z")," option with ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," in all of the examples,\nwhich causes ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," to format the output as ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/formats/zson"},"ZSON"),".\nWhen running ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," on the terminal, you do not need ",(0,s.kt)("inlineCode",{parentName:"p"},"-z")," as it is the default,\nbut we include it here for clarity and because all of these examples are\nrun through automated testing, which is not attached to a terminal.")),(0,s.kt)("h2",{id:"search-vs-transformation"},"Search vs Transformation"),(0,s.kt)("p",null,"Unlike ",(0,s.kt)("inlineCode",{parentName:"p"},"jq"),", which leads with ",(0,s.kt)("em",{parentName:"p"},"transformation"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," leads with ",(0,s.kt)("em",{parentName:"p"},"search")," but\ntransformation is also pretty easy.  Let's show what we mean here with an\nexample."),(0,s.kt)("p",null,"If we run this ",(0,s.kt)("inlineCode",{parentName:"p"},"jq")," command,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"echo '1 2 3' | jq 2\n")),(0,s.kt)("p",null,"we get"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"2\n2\n2\n")),(0,s.kt)("p",null,"Hmm, that's a little odd, but it did what we told it to do.  In ",(0,s.kt)("inlineCode",{parentName:"p"},"jq"),", the\nexpression ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," is evaluated for each input value, and the value ",(0,s.kt)("inlineCode",{parentName:"p"},"2"),"\nis produced each time, so three copies of ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," are emitted."),(0,s.kt)("p",null,"In ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," however, ",(0,s.kt)("inlineCode",{parentName:"p"},"2")," by itself is interpreted as a search and is\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/overview#26-implied-operators"},"shorthand for")," ",(0,s.kt)("inlineCode",{parentName:"p"},"search 2")," so the command"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 2 3' | zq -z 2 -\n")),(0,s.kt)("p",null,'produces this "search result":'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"2\n")),(0,s.kt)("p",null,"In fact, this search syntax generalizes, and if we search over a more complex\ninput:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'1 2 [1,2,3] [4,5,6] {r:{x:1,y:2}} {r:{x:3,y:4}} "hello" "Number 2"\' | zq -z 2 -\n')),(0,s.kt)("p",null,"we naturally find all the 2's whether as a value, inside a value, or inside a string:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'2\n[1,2,3]\n{r:{x:1,y:2}}\n"Number 2"\n')),(0,s.kt)("p",null,"You can also do keyword-text search, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 2 [1,2,3] [4,5,6] {r:{x:1,y:2}} {r:{x:3,y:4}} \"hello\" \"Number 2\"' | zq -z 'hello or Number' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'"hello"\n"Number 2"\n')),(0,s.kt)("p",null,"Doing searches like this in ",(0,s.kt)("inlineCode",{parentName:"p"},"jq")," would be hard."),(0,s.kt)("p",null,"That said, we can emulate the ",(0,s.kt)("inlineCode",{parentName:"p"},"jq")," transformation stance by explicitly\nindicating that we want to ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/yield"},"yield"),"\nthe result of the expression evaluated for each input value, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 2 3' | zq -z 'yield 2' -\n")),(0,s.kt)("p",null,"now gives the same answer as ",(0,s.kt)("inlineCode",{parentName:"p"},"jq"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"2\n2\n2\n")),(0,s.kt)("p",null,"Cool, but doesn't it seem like search is a better disposition for\nshorthand syntax?  What do you think?"),(0,s.kt)("h2",{id:"on-to-zson"},"On to ZSON"),(0,s.kt)("p",null,"JSON is super easy and ubiquitous, but it can be limiting and frustrating when\ntrying to do high-precision stuff with data."),(0,s.kt)("p",null,"When using ",(0,s.kt)("inlineCode",{parentName:"p"},"zq"),", it's handy to operate in the\ndomain of Zed data and only output to JSON when needed."),(0,s.kt)("p",null,"The human-readable format of Zed is called ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/formats/zson"},"ZSON"),"\n(and yes, that's a play on the acronym JSON)."),(0,s.kt)("p",null,"ZSON is nice because it has a comprehensive type system and you can\ngo from ZSON to an efficient binary row format (",(0,s.kt)("a",{parentName:"p",href:"/docs/next/formats/zng"},"ZNG"),")\nand columnar (",(0,s.kt)("a",{parentName:"p",href:"/docs/next/formats/zst"},"ZST"),") --- and vice versa ---\nwith complete fidelity and no loss of information.  In this tour,\nwe'll stick to ZSON (though for large data sets,\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/commands/zq#7-performance"},"ZNG is much faster"),")."),(0,s.kt)("p",null,"The first thing you'll notice about ZSON is that you don't need\nquotations around field names.  We can see this by taking some JSON\nas input (the JSON format is auto-detected by ",(0,s.kt)("inlineCode",{parentName:"p"},"zq"),") and formatting\nit as pretty-printed ZSON with ",(0,s.kt)("inlineCode",{parentName:"p"},"-Z"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{"s":"hello","val":1,"a":[1,2],"b":true}\' | zq -Z -\n')),(0,s.kt)("p",null,"which gives"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n    s: "hello",\n    val: 1,\n    a: [\n        1,\n        2\n    ],\n    b: true\n}\n')),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"s"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"val"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"a"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"b")," all appear as unquoted identifiers here.\nOf course if you have funny characters in a field name, ZSON can handle\nit with quotes just like JSON:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{\"funny@name\":1}' | zq -z -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{"funny@name":1}\n')),(0,s.kt)("p",null,"Moreover, ZSON is fully compatible with all of JSON's corner cases like empty string\nas a field name and empty object as a value, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{\"\":{}}' | zq -z -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{"":{}}\n')),(0,s.kt)("h2",{id:"comprehensive-types"},"Comprehensive Types"),(0,s.kt)("p",null,"ZSON also has a ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/formats/zed"},"comprehensive type system"),"."),(0,s.kt)("p",null,'For example, here is ZSON "record" with a taste of different types\nof values as record fields:'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'{\n    v1: 1.5,\n    v2: 1,\n    v3: 1 (uint8),\n    v4: 2018-03-24T17:30:20.600852Z,\n    v5: 2m30s,\n    v6: 192.168.1.1,\n    v7: 192.168.1.0/24,\n    v8: [\n        1,\n        2,\n        3\n    ],\n    v9: |[\n        "GET",\n        "PUT",\n        "POST"\n    ]|,\n    v10: |{\n        "key1": 123,\n        "key2": 456\n    }|,\n    v11: {\n        a: 1,\n        r: {\n            s1: "hello",\n            s2: "world"\n        }\n    }\n}\n')),(0,s.kt)("p",null,"Here, ",(0,s.kt)("inlineCode",{parentName:"p"},"v1")," is a 64-bit IEEE floating-point value just like JSON."),(0,s.kt)("p",null,"Unlike JSON, ",(0,s.kt)("inlineCode",{parentName:"p"},"v2")," is a 64-bit integer.  And there are other integer\ntypes as with ",(0,s.kt)("inlineCode",{parentName:"p"},"v3"),",\nwhich utilizes a ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/formats/zson#22-type-decorators"},"ZSON type decorator"),",\nin this case,\nto clarify its specific type of integer as unsigned 8 bits."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"v4")," has type ",(0,s.kt)("inlineCode",{parentName:"p"},"time")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"v5")," type ",(0,s.kt)("inlineCode",{parentName:"p"},"duration"),"."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"v6")," is type ",(0,s.kt)("inlineCode",{parentName:"p"},"ip")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"v7")," type ",(0,s.kt)("inlineCode",{parentName:"p"},"net"),"."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"v8")," is an array of elements of type ",(0,s.kt)("inlineCode",{parentName:"p"},"int64"),", which in Zed, is a type\nwritten as ",(0,s.kt)("inlineCode",{parentName:"p"},"[int64]"),"."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"v9"),' is a "set of strings", which is written like an array but with the\nenclosing syntax ',(0,s.kt)("inlineCode",{parentName:"p"},"|[")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"]|"),"."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"v10"),' is a "map" type, which in other languages is often called a "table"\nor a "dictionary".  In Zed, a value of any type can be used for the key or the\nvalue though all of the keys and all of the values must have the same type.'),(0,s.kt)("p",null,"Finally, ",(0,s.kt)("inlineCode",{parentName:"p"},"v11"),' is a Zed "record", which is similar to a JSON "object", but the\nkeys are called "fields", the order of the fields is significant and\nis always preserved.'),(0,s.kt)("h2",{id:"records"},"Records"),(0,s.kt)("p",null,'As is often the case with semi-structured systems, you deal with\nnested values all the time: in JSON, data is nested with objects and arrays,\nwhile in Zed, data is nested with "records" and arrays (as well as other complex types).'),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/overview#6112-record-expressions"},"Record expressions"),"\nare rather flexible with ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," and look a bit like JavaScript\nor ",(0,s.kt)("inlineCode",{parentName:"p"},"jq")," syntax, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 2 3' | zq -z 'yield {kind:\"counter\",val:this}' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{kind:"counter",val:1}\n{kind:"counter",val:2}\n{kind:"counter",val:3}\n')),(0,s.kt)("p",null,"Note that like the search shortcut, you can also drop the yield keyword\nhere because the record literal implies the yield operator, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 2 3' | zq -z '{kind:\"counter\",val:this}' -\n")),(0,s.kt)("p",null,"also produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{kind:"counter",val:1}\n{kind:"counter",val:2}\n{kind:"counter",val:3}\n')),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"zq")," can also use a spread operator like JavaScript, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{a:{s:"foo", val:1}}{b:{s:"bar"}}\' | zq -z \'{...a,s:"baz"}\' -\n')),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"baz",val:1}\n{s:"baz"}\n')),(0,s.kt)("p",null,"while"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{a:{s:\"foo\", val:1}}{b:{s:\"bar\"}}' | zq -z '{d:2,...a,...b}' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{d:2,s:"foo",val:1}\n{d:2,s:"bar"}\n')),(0,s.kt)("h2",{id:"record-mutation"},"Record Mutation"),(0,s.kt)("p",null,"Sometimes you just want to extract or mutate certain fields of records."),(0,s.kt)("p",null,"Similar to the Unix ",(0,s.kt)("inlineCode",{parentName:"p"},"cut")," command, the Zed ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/cut"},"cut operator"),"\nextracts fields, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{s:\"foo\", val:1}{s:\"bar\"}' | zq -z 'cut s' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"foo"}\n{s:"bar"}\n')),(0,s.kt)("p",null,"while the ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/put"},"put operator")," mutates existing fields\nor adds new fields, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{s:\"foo\", val:1}{s:\"bar\"}' | zq -z 'put val:=123,pi:=3.14' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"foo",val:123,pi:3.14}\n{s:"bar",val:123,pi:3.14}\n')),(0,s.kt)("p",null,"Note that ",(0,s.kt)("inlineCode",{parentName:"p"},"put")," is also an implied operator so the command with ",(0,s.kt)("inlineCode",{parentName:"p"},"put")," omitted"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{s:\"foo\", val:1}{s:\"bar\"}' | zq -z 'val:=123,pi:=3.14' -\n")),(0,s.kt)("p",null,"produces the very same output:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"foo",val:123,pi:3.14}\n{s:"bar",val:123,pi:3.14}\n')),(0,s.kt)("p",null,"Finally, it's worth mentioning that errors in Zed are\n",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/First-class_citizen"},"first class"),".\nThis means they can just show up in the data as values.  In particular,\na common error is ",(0,s.kt)("inlineCode",{parentName:"p"},'error("missing")')," which occurs most often when referencing\na field that does not exist, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{s:\"foo\", val:1}{s:\"bar\"}' | zq -z 'cut val' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{val:1}\n{val:error("missing")}\n')),(0,s.kt)("p",null,"Sometimes you expect missing errors to occur sporadically and just want\nto ignore them, which can you easily do with the\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/functions/quiet"},"quiet function"),", e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{s:\"foo\", val:1}{s:\"bar\"}' | zq -z 'cut quiet(val)' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{val:1}\n")),(0,s.kt)("h2",{id:"union-types"},"Union Types"),(0,s.kt)("p",null,"One of the tricks ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," uses to represent JSON data in its structured type system\nis ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/overview#6116-union-values"},"union types"),".\nMost of the time, you don't need to worry about unions\nbut they show up from time to time.  Even when\nthey show up, Zed just tries to \"do the right thing\" so you usually\ndon't have to worry about them even when they show up."),(0,s.kt)("p",null,"For example, this query is perfectly happy to operate on the union values\nthat are implied by a mixed-type array:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '[1, \"foo\", 2, \"bar\"]' | zq -z 'yield this[2],this[1]' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'2\n"foo"\n')),(0,s.kt)("p",null,"but under the covers, the elements of the array have a union type of\n",(0,s.kt)("inlineCode",{parentName:"p"},"int64")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"string"),", which is written ",(0,s.kt)("inlineCode",{parentName:"p"},"(int64,string)"),", e.g,."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '[1, \"foo\", 2, \"bar\"]' | zq -z 'yield typeof(this)' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"<[(int64,string)]>\n")),(0,s.kt)("p",null,"which is a type value representing an array of union values."),(0,s.kt)("p",null,"As you learn more about Zed and want to use ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," to do data discovery and\npreparation, union types are really quite powerful.  They allow records\nwith fields of different types or mixed-type arrays to be easily expressed\nwhile also having a very precise type definition.  This is the essence\nof Zed's new\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/formats/#2-zed-a-super-structured-pattern"},"super-structured data model"),"."),(0,s.kt)("h2",{id:"first-class-types"},"First-class Types"),(0,s.kt)("p",null,"Note that in the type value above, the type is wrapped in angle brackets.\nThis is how ZSON represents types when expressed as values.\nIn other words, Zed has\n",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/First-class_citizen"},"first-class")," types."),(0,s.kt)("p",null,"The type of any value in ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," can be accessed via the\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/functions/typeof"},"typeof function"),", e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 \"foo\" 10.0.0.1' | zq -z 'yield typeof(this)' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"<int64>\n<string>\n<ip>\n")),(0,s.kt)("p",null,"What's the big deal here?  We can print out the type of something.  Yawn."),(0,s.kt)("p",null,"Au contraire, this is really quite powerful because we can\nuse types as values to functions, e.g., as a dynamic argument to\nthe ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/functions/cast"},"cast function"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{a:0,b:\"2\"}{a:0,b:\"3\"}' | zq -z 'yield cast(b, typeof(a))' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"2\n3\n")),(0,s.kt)("p",null,"But more powerfully, types can be used anywhere a value can be used and\nin particular, they can be group-by keys, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{x:1,y:2}{s:"foo"}{x:3,y:4}\' | zq -f table "count() by shape:=typeof(this) | sort count" -\n')),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"shape               count\n<{s:string}>        1\n<{x:int64,y:int64}> 2\n")),(0,s.kt)("p",null,'When run over large data sets, this gives you an insightful count of\neach "shape" of data in the input.  This is a powerful building block for\ndata discovery.'),(0,s.kt)("p",null,"It's worth mentioning ",(0,s.kt)("inlineCode",{parentName:"p"},"jq")," also has a type operator, but it produces a\nsimple string instead of first-class types, and arrays and objects have\nno detail about their structure, e,g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'echo \'1 true [1,2,3] {"s":"foo"}\' | jq type\n')),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'"number"\n"boolean"\n"array"\n"object"\n')),(0,s.kt)("p",null,"Moreover, if we compare types of different objects"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'echo \'{"a":{"s":"foo"},"b":{"x":1,"y":2}}\' | jq \'(.a|type)==(.b|type)\'\n')),(0,s.kt)("p",null,'we get "object" here for each type and thus the result:'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"true\n")),(0,s.kt)("p",null,"i.e., they match even though their underlying shape is different."),(0,s.kt)("p",null,"With ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," of course, these are different super-structured types so\nthe result is false, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{"a":{"s":"foo"},"b":{"x":1,"y":2}}\' | zq -z \'yield typeof(a)==typeof(b)\' -\n')),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"false\n")),(0,s.kt)("h2",{id:"sample"},"Sample"),(0,s.kt)("p",null,"Sometimes you'd like to see a sample value of each shape, not its type.\nThis is easy to do with the ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/aggregates/any"},"any aggregate function"),",\ne.g,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{x:1,y:2}{s:\"foo\"}{x:3,y:4}' | zq -z 'val:=any(this) by typeof(this) | sort val | yield val' -\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"foo"}\n{x:1,y:2}\n')),(0,s.kt)("p",null,"We like this pattern so much there is a shortcut ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/sample"},"sample operator"),", e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{x:1,y:2}{s:\"foo\"}{x:3,y:4}' | zq -z 'sample this | sort this' -\n")),(0,s.kt)("p",null,"emits the same result:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"foo"}\n{x:1,y:2}\n')),(0,s.kt)("h2",{id:"fuse"},"Fuse"),(0,s.kt)("p",null,"Sometimes JSON data can get really messy with lots of variations in fields,\nwith null values appearing sometimes and sometimes not, and with the same\nfields having different data types.  Most annoyingly, when you see a JSON object\nlike this in isolation:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"{a:1,b:null}\n")),(0,s.kt)("p",null,"you have no idea what the expected data type of ",(0,s.kt)("inlineCode",{parentName:"p"},"b")," will be.  Maybe it's another\nnumber?  Or maybe a string?  Or maybe an array or an embedded object?"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"zq")," and ZSON don't have this problem because every value (even ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),") is\ncomprehensively typed.  However, ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," in fact must deal with this thorny problem\nwhen reading JSON and converting it to Zed's super-structure."),(0,s.kt)("p",null,"This is where you might have to spend a little bit of time coding up\nthe right ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," logic to disentangle a JSON mess. But once the data is cleaned up,\nyou can leave it in a Zed format and not worry again."),(0,s.kt)("p",null,"To do so, the ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/fuse"},"fuse operator")," comes in handy.\nLet's say you have this sequence of data:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"{a:1,b:null}\n{a:null,b:[2,3,4]}\n")),(0,s.kt)("p",null,"As we said,\nyou can't tell by looking at either value what the types of both ",(0,s.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"b"),"\nshould be.  But if you merge the values into a common type, things begin to make\nsense, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{a:1,b:null}{a:null,b:[2,3,4]}' | zq -z fuse -\n")),(0,s.kt)("p",null,"produces this transformed and comprehensively-typed ZSON output:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{a:1,b:null([int64])}\n{a:null(int64),b:[2,3,4]}\n")),(0,s.kt)("p",null,"Now you can see all the detail."),(0,s.kt)("p",null,"This turns out to be so useful, especially with large amounts of messy input data,\nyou will often find yourself fusing data then sampling it, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{a:1,b:null}{a:null,b:[2,3,4]}' | zq -Z 'fuse | sample' -\n")),(0,s.kt)("p",null,"produces a comprehensively-typed sample:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{\n    a: 1,\n    b: null ([int64])\n}\n")),(0,s.kt)("p",null,"As you explore data in this fashion, you will often type various searches\nto slice and dice the data as you get a feel for it all while sending\nyour interactive search results to ",(0,s.kt)("inlineCode",{parentName:"p"},"fuse | sample"),"."),(0,s.kt)("p",null,"To appreciate all this, let's have a look next at some real-world data..."),(0,s.kt)("h2",{id:"real-world-github-data"},"Real-world GitHub Data"),(0,s.kt)("p",null,"Now that we've covered the basics of ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," and the Zed language, let's\nuse the query patterns from above to explore some GitHub data."),(0,s.kt)("p",null,"First, we need to grab the data.  You can use ",(0,s.kt)("inlineCode",{parentName:"p"},"curl")," for this or you can\njust use ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," as ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," can take URLs in addition to file name arguments.\nThis command will grab descriptions of first 30 PRs created in the\npublic ",(0,s.kt)("inlineCode",{parentName:"p"},"zed")," repository and place it in a file called ",(0,s.kt)("inlineCode",{parentName:"p"},"prs.json"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq -f json https://api.github.com/repos/brimdata/zed/pulls\\?state\\=all\\&sort\\=desc\\&per_page=30 > prs.json\n")),(0,s.kt)("p",null,"Now that you have this JSON file on your local file system, how would you query it\nwith ",(0,s.kt)("inlineCode",{parentName:"p"},"zq"),"?"),(0,s.kt)("h3",{id:"data-discovery"},"Data Discovery"),(0,s.kt)("p",null,"Before you can do anything, you need to know its structure but you generally don't\nknow anything after pulling some random data from an API."),(0,s.kt)("p",null,"So, let's poke around a bit and figure it out.  This process of data introspection\nis often called ",(0,s.kt)("em",{parentName:"p"},"data discovery"),"."),(0,s.kt)("p",null,"You could start by using ",(0,s.kt)("inlineCode",{parentName:"p"},"jq")," to pretty-print the JSON data,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"jq . prs.json\n")),(0,s.kt)("p",null,"That's 10,592 lines.  Ugh, quite a challenge to sift through."),(0,s.kt)("p",null,"Instead, let's start out by figuring out how many values are in the input, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -f text 'count()' prs.json\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"1\n")),(0,s.kt)("p",null,"Hmm, there's just one value.  It's probably a big JSON array but let's check with\nthe ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/functions/kind"},"kind function"),", and as expected:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'kind(this)' prs.json\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'"array"\n')),(0,s.kt)("p",null,"Ok got it.  But, how many items are in the array?  "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'len(this)' prs.json\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"30\n")),(0,s.kt)("p",null,"Of course!  We asked GitHub to return 30 items and the API returns the\npull-request objects as elements of one array representing a single JSON value."),(0,s.kt)("p",null,"Let's see what sorts of things are in this array.  Here, we need to enumerate\nthe items from the array and do something with them.  So how about we use\nthe ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/over"},"over operator"),'\nto traverse the array and count the array items by their "kind",'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over this | count() by kind(this)' prs.json\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{kind:"record",count:30(uint64)}\n')),(0,s.kt)("p",null,"Ok, they're all records.  Good, this should be easy!"),(0,s.kt)("p",null,'The Zed records were all originally JSON objects.\nMaybe we can just use "sample" to have a deeper look...'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq -Z 'over this | sample' prs.json\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Here we are using ",(0,s.kt)("inlineCode",{parentName:"p"},"-Z"),", which is like ",(0,s.kt)("inlineCode",{parentName:"p"},"-z"),", but instead of formatting each\nZSON value on its own line, it pretty-prints the ZSON with vertical\nformatting like ",(0,s.kt)("inlineCode",{parentName:"p"},"jq")," does for JSON.")),(0,s.kt)("p",null,"Ugh, that output is still pretty big.  It's not 10k lines but it's still\nmore than 700 lines of pretty-printed ZSON."),(0,s.kt)("p",null,"Ok, maybe it's not so bad.  Let's check how many shapes there are with ",(0,s.kt)("inlineCode",{parentName:"p"},"sample"),"..."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over this | sample | count()' prs.json\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{count:3(uint64)}\n")),(0,s.kt)("p",null,"All that data across the samples and only three shapes.\nThey must each be really big.  Let's check that out."),(0,s.kt)("p",null,"We can use the ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/functions/len"},"len function")," on the records to\nsee the size of each of the four records:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over this | sample | len(this) | sort this' prs.json\n")),(0,s.kt)("p",null,"and we get"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"0\n36\n36\n")),(0,s.kt)("p",null,"Ok, this isn't so bad... two shapes each have 36 fields but one is length zero?!\nThat outlier could only be the empty record.  Let's check:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over this | sample | len(this)==0' prs.json\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{}\n")),(0,s.kt)("p",null,"Sure enough, there it is.  We could also double check with ",(0,s.kt)("inlineCode",{parentName:"p"},"jq")," that there are\nblank records in the GitHub results, and sure enough"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"jq '.[] | select(length==0)' prs.json\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"{}\n{}\n")),(0,s.kt)("p",null,"Try opening your editor on that JSON file to look for the empty objects.\nWho knows why they are there?  No fun. Real-world data is messy."),(0,s.kt)("p",null,"How about we fuse the 3 shapes together and have a look at the result:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq -Z 'over this | fuse | sample' prs.json\n")),(0,s.kt)("p",null,"We won't display the result here as it's still pretty big.  But you can\ngive it a try.  It's 379 lines."),(0,s.kt)("p",null,"But let's break down what's taking up all this space."),(0,s.kt)("p",null,"We can take the output from ",(0,s.kt)("inlineCode",{parentName:"p"},"fuse | sample"),' and list the fields with\nand their "kind".  Note that when we do an ',(0,s.kt)("inlineCode",{parentName:"p"},"over this")," with records as\ninput, we get a new record value for each field structured as a key/value pair:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -f table 'over this | fuse | sample | over this | {field:key[0],kind:kind(value)}' prs.json\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"field               kind\nurl                 primitive\nid                  primitive\nnode_id             primitive\nhtml_url            primitive\ndiff_url            primitive\npatch_url           primitive\nissue_url           primitive\nnumber              primitive\nstate               primitive\nlocked              primitive\ntitle               primitive\nuser                record\nbody                primitive\ncreated_at          primitive\nupdated_at          primitive\nclosed_at           primitive\nmerged_at           primitive\nmerge_commit_sha    primitive\nassignee            primitive\nassignees           array\nrequested_reviewers array\nrequested_teams     array\nlabels              array\nmilestone           primitive\ndraft               primitive\ncommits_url         primitive\nreview_comments_url primitive\nreview_comment_url  primitive\ncomments_url        primitive\nstatuses_url        primitive\nhead                record\nbase                record\n_links              record\nauthor_association  primitive\nauto_merge          primitive\nactive_lock_reason  primitive\n")),(0,s.kt)("p",null,"With this list of top-level fields, we can easily explore the different\npieces of their structure with sample.  Let's have a look at a few of the\nrecord fields by giving these one-liners each a try and looking at the output:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq -Z 'over this | sample head' prs.json\nzq -Z 'over this | sample base' prs.json\nzq -Z 'over this | sample _links' prs.json\n")),(0,s.kt)("p",null,"While these fields have some useful information, we'll decide to drop them here\nand focus on other top-level fields.  To do this, we can use the\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/drop"},"drop operator")," to whittle down the data:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq -Z 'over this | fuse | drop head,base,_link | sample' prs.json\n")),(0,s.kt)("p",null,"Ok, this looks more reasonable and is now only 120 lines of pretty-printed ZSON."),(0,s.kt)("p",null,"One more annoying detail here about JSON: time values are stored as strings,\nin this case, in ISO format, e.g., we can pull this value out with\nthis query:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over this | head 1 | yield created_at' prs.json\n")),(0,s.kt)("p",null,"which produces this string:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'"2019-11-11T19:50:46Z"\n')),(0,s.kt)("p",null,"Since Zed has a native ",(0,s.kt)("inlineCode",{parentName:"p"},"time")," type and we might want to do native date comparisons\non these time fields, we can easily translate the string to a time with a cast, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over this | head 1 | yield time(created_at)' prs.json\n")),(0,s.kt)("p",null,"produces the native time value:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"2019-11-11T19:50:46Z\n")),(0,s.kt)("p",null,"To be sure, you can check any value's type with the ",(0,s.kt)("inlineCode",{parentName:"p"},"tyepof")," function, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over this | head 1 | yield time(created_at) | typeof(this)' prs.json\n")),(0,s.kt)("p",null,"produces the native time value:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"<time>\n")),(0,s.kt)("h3",{id:"cleaning-up-the-messy-json"},"Cleaning up the Messy JSON"),(0,s.kt)("p",null,"Okay, now that we've explored the data, we have a sense of it and can\n\"clean it up\" with some Zed logic.  We'll do this one step at a time,\nthen put it all together."),(0,s.kt)("p",null,"First, let's get rid of the outer array and generate elements of an array\nas a sequence of Zed records that have been fused and let's filter out\nthe empty records:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq 'over this | len(this) != 0 | fuse' prs.json > prs1.zng\n")),(0,s.kt)("p",null,"We can check that worked with count:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq -z 'count()' prs1.zng\nzq -z 'sample | count()' prs1.zng\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"{count:28(uint64)}\n{count:1(uint64)}\n")),(0,s.kt)("p",null,"Okay, good.  There are 28 values (the 30 requested less the two empty records)\nand exactly one shape since the data was fused."),(0,s.kt)("p",null,"Now, let's drop the fields we aren't interested in:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq 'drop head,base,_links' prs1.zng > prs2.zng\n")),(0,s.kt)("p",null,"Finally, let's clean up those dates.  To track down all the candidates,\nwe can run this Zed to group field names by their type and limit the output\nto primitive types:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq -z 'over this | kind(value)==\"primitive\" | fields:=union(key[0]) by type:=typeof(value)' prs2.zng\n")),(0,s.kt)("p",null,"which gives"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'{type:<string>,fields:|["url","body","state","title","node_id","diff_url","html_url","closed_at","issue_url","merged_at","patch_url","created_at","updated_at","commits_url","comments_url","statuses_url","merge_commit_sha","author_association","review_comment_url","review_comments_url"]|}\n{type:<int64>,fields:|["id","number"]|}\n{type:<bool>,fields:|["draft","locked"]|}\n{type:<null>,fields:|["assignee","milestone","auto_merge","active_lock_reason"]|}\n')),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note that this use of ",(0,s.kt)("inlineCode",{parentName:"p"},"over")," traverses each record and generates a key-value pair\nfor each field in each record.")),(0,s.kt)("p",null,"Looking through the fields that are strings, the candidates for ISO dates appear\nto be"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"closed_at"),","),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"merged_at"),","),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"created_at"),", and"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"updated_at"),".\nYou can do a quick check of the theory by running...")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq -z '{closed_at,merged_at,created_at,updated_at}' prs2.zng\n")),(0,s.kt)("p",null,"and you will get strings that are all ISO dates:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},'{closed_at:"2019-11-11T20:00:22Z",merged_at:"2019-11-11T20:00:22Z",created_at:"2019-11-11T19:50:46Z",updated_at:"2019-11-11T20:00:25Z"}\n{closed_at:"2019-11-11T21:00:15Z",merged_at:"2019-11-11T21:00:15Z",created_at:"2019-11-11T20:57:12Z",updated_at:"2019-11-11T21:00:26Z"}\n...\n')),(0,s.kt)("p",null,"To fix those strings, we simply transform the fields in place using the\n(implied) ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/put"},"put operator")," and redirect the final\noutput the ZNG file ",(0,s.kt)("inlineCode",{parentName:"p"},"prs.zng"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq 'closed_at:=time(closed_at),merged_at:=time(merged_at),created_at:=time(created_at),updated_at:=time(updated_at)' prs2.zng > prs.zng\n")),(0,s.kt)("p",null,"We can check the result with our type analysis:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over this | kind(value)==\"primitive\" | fields:=union(key[0]) by type:=typeof(value) | sort type' prs.zng\n")),(0,s.kt)("p",null,"which now gives:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{type:<int64>,fields:|["id","number"]|}\n{type:<time>,fields:|["closed_at","merged_at","created_at","updated_at"]|}\n{type:<bool>,fields:|["draft","locked"]|}\n{type:<string>,fields:|["url","body","state","title","node_id","diff_url","html_url","issue_url","patch_url","commits_url","comments_url","statuses_url","merge_commit_sha","author_association","review_comment_url","review_comments_url"]|}\n{type:<null>,fields:|["assignee","milestone","auto_merge","active_lock_reason"]|}\n')),(0,s.kt)("p",null,"and we can see that the date fields are correctly typed as type ",(0,s.kt)("inlineCode",{parentName:"p"},"time"),"!"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note that we sorted the output values here using the ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/sort"},"sort operator"),"\nto produce a consistent output order since aggregations can be run in parallel\nto achieve scale and do not guarantee their output order.")),(0,s.kt)("h2",{id:"putting-it-all-together"},"Putting It All Together"),(0,s.kt)("p",null,"Instead of running each step above into a temporary file, we can\nput all the transformations together in a single\nZed pipeline, where the Zed source text might look like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"over this                      // traverse the array of objects\n| len(this) != 0               // skip empty objects\n| fuse                         // fuse objects into records of a combined type\n| drop head,base,_links        // drop fields that we don't need\n| closed_at:=time(closed_at),  // transform string dates to type time\n  merged_at:=time(merged_at),\n  created_at:=time(created_at),\n  updated_at:=time(updated_at)\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note that the ",(0,s.kt)("inlineCode",{parentName:"p"},"//")," syntax indicates a single-line comment.")),(0,s.kt)("p",null,"We can then put this in a file, called say ",(0,s.kt)("inlineCode",{parentName:"p"},"transform.zed"),", and use the ",(0,s.kt)("inlineCode",{parentName:"p"},"-I"),"\nargument to run all the transformations in one fell swoop:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"zq -I transform.zed prs.json > prs.zng\n")),(0,s.kt)("h2",{id:"running-analytics"},"Running Analytics"),(0,s.kt)("p",null,"Now that we've cleaned up our data, we can reliably and easily run analytics\non the finalized ZNG file ",(0,s.kt)("inlineCode",{parentName:"p"},"prs.zng"),"."),(0,s.kt)("p",null,"Zed gives us the best of both worlds of JSON and relational tables: we have\nthe structure and clarity of the relational model while retaining the flexibility\nof JSON's document model.  No need to create tables then issue SQL insert commands\nto put your clean data into all the right places."),(0,s.kt)("p",null,'Let\'s start with something simple.  How about we output a "PR Report" listing\nthe title of each PR along with its PR number and creation date:'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -f table '{DATE:created_at,NUMBER:\"PR #${number}\",TITLE:title}' prs.zng\n")),(0,s.kt)("p",null,"and you'll see this output..."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output",metastring:"head",head:!0},'DATE                 NUMBER TITLE\n2019-11-11T19:50:46Z PR #1  Make "make" work in zq\n2019-11-11T20:57:12Z PR #2  fix install target\n2019-11-11T23:24:00Z PR #3  import github.com/looky-cloud/lookytalk\n2019-11-12T16:25:46Z PR #5  Make zq -f work\n2019-11-12T16:49:07Z PR #6  a few clarifications to the zson spec\n...\n')),(0,s.kt)("p",null,"Note that we used ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/overview#6111-string-interpolation"},"string interpolation"),"\nto convert the field ",(0,s.kt)("inlineCode",{parentName:"p"},"number")," into a string and format it with surrounding text."),(0,s.kt)("p",null,"Instead of old PRs, we can get the latest list of PRs using the\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/operators/tail"},"tail operator")," since we know the data is sorted\nchronologically. This command retrieves the last five PRs in the dataset:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},'zq -f table \'tail 5 | {DATE:created_at,"NUMBER":"PR #${number}",TITLE:title}\' prs.zng\n')),(0,s.kt)("p",null,"and the output is:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'DATE                 NUMBER TITLE\n2019-11-18T22:14:08Z PR #26 ndjson writer\n2019-11-18T22:43:07Z PR #27 Add reader for ndjson input\n2019-11-19T00:11:46Z PR #28 fix TS_ISO8601, TS_MILLIS handling in NewRawAndTsFromJSON\n2019-11-19T21:14:46Z PR #29 Return count of "dropped" fields from zson.NewRawAndTsFromJSON\n2019-11-20T00:36:30Z PR #30 zval.sizeBytes incorrect\n')),(0,s.kt)("p",null,"How about some aggregations?  We can count the number of PRs and sort by the\ncount highest first:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},'zq -z "count() by user:=user.login | sort -r count" prs.zng\n')),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{user:"mattnibs",count:10(uint64)}\n{user:"aswan",count:7(uint64)}\n{user:"mccanne",count:6(uint64)}\n{user:"nwt",count:4(uint64)}\n{user:"henridf",count:1(uint64)}\n')),(0,s.kt)("p",null,"How about getting a list of all of the reviewers?  To do this, we need to\ntraverse the records in the ",(0,s.kt)("inlineCode",{parentName:"p"},"requested_reviewers")," array and collect up\nthe login field from each record:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over requested_reviewers | collect(login)' prs.zng\n")),(0,s.kt)("p",null,"Oops, this gives us an array of the reviewer logins\nwith repetitions since ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/aggregates/collect"},"collect"),"\ncollects each item that it encounters into an array:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{collect:["mccanne","nwt","henridf","mccanne","nwt","mccanne","mattnibs","henridf","mccanne","mattnibs","henridf","mccanne","mattnibs","henridf","mccanne","nwt","aswan","henridf","mccanne","nwt","aswan","philrz","mccanne","mccanne","aswan","henridf","aswan","mccanne","nwt","aswan","mikesbrown","henridf","aswan","mattnibs","henridf","mccanne","aswan","nwt","henridf","mattnibs","aswan","aswan","mattnibs","aswan","henridf","aswan","henridf","mccanne","aswan","aswan","mccanne","nwt","aswan","henridf","aswan"]}\n')),(0,s.kt)("p",null,"What we'd prefer is a set of reviewers where each reviewer appears only once.  This\nis easily done with the ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/aggregates/union"},"union")," aggregate function\n(not to be confused with union types) which\ncomputes the set-wise union of its input and produces a Zed ",(0,s.kt)("inlineCode",{parentName:"p"},"set")," type as its\noutput.  In this case, the output is a set of strings, written ",(0,s.kt)("inlineCode",{parentName:"p"},"|[string]|"),"\nin the Zed language.  For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over requested_reviewers | reviewers:=union(login)' prs.zng\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{reviewers:|["nwt","aswan","philrz","henridf","mccanne","mattnibs","mikesbrown"]|}\n')),(0,s.kt)("p",null,"Ok, that's pretty neat."),(0,s.kt)("p",null,"Let's close with an analysis that's a bit more sophisticated.  Suppose we want\nto look at the reviewers that each user tends to ask for.  We can think about\nthis question as a \"graph problem\" where the user requesting reviews is one node\nin the graph and each set of reviewers is another node."),(0,s.kt)("p",null,"So as a first step, let's figure out how to create each edge, where an edge\nis a relation between the requesting user and the set of reviewers.  We can\ncreate this in Zed with a ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/overview#8-lateral-subqueries"},'"lateral subquery"'),".\nInstead of computing a set-union over all the reviewers across all PRs,\nwe instead want to compute the set-union over the reviewers in each PR.\nWe can do this as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over requested_reviewers => ( reviewers:=union(login) )' prs.zng\n")),(0,s.kt)("p",null,"which produces an output like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output",metastring:"head",head:!0},'{reviewers:|["nwt","mccanne"]|}\n{reviewers:|["nwt","henridf","mccanne"]|}\n{reviewers:|["mccanne","mattnibs"]|}\n{reviewers:|["henridf","mccanne","mattnibs"]|}\n{reviewers:|["henridf","mccanne","mattnibs"]|}\n...\n')),(0,s.kt)("p",null,"Note that the syntax ",(0,s.kt)("inlineCode",{parentName:"p"},"=> ( ... )")," defines a ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/overview#81-lateral-scope"},"lateral scope")," where any Zed subquery can\nrun in isolation over the input values created from the sequence of values\ntraversed by the outer ",(0,s.kt)("inlineCode",{parentName:"p"},"over"),"."),(0,s.kt)("p",null,'But we need a "graph edge" between the requesting user and the reviewers.\nTo do this, we need to reference the ',(0,s.kt)("inlineCode",{parentName:"p"},"user.login")," from the top-level scope within the\nlateral scope.  This can be done by\nbringing that value into the scope using a ",(0,s.kt)("inlineCode",{parentName:"p"},"with")," clause appended to the\n",(0,s.kt)("inlineCode",{parentName:"p"},"over")," expression and yielding a\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/overview#6112-record-expressions"},"record literal")," with the desired value:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over requested_reviewers with user=user.login => ( reviewers:=union(login) | {user,reviewers}) | sort user,len(reviewers)' prs.zng\n")),(0,s.kt)("p",null,"which gives us"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output",metastring:"head",head:!0},'{user:"aswan",reviewers:|["mccanne"]|}\n{user:"aswan",reviewers:|["nwt","mccanne"]|}\n{user:"aswan",reviewers:|["nwt","henridf","mccanne"]|}\n{user:"aswan",reviewers:|["henridf","mccanne","mattnibs"]|}\n{user:"aswan",reviewers:|["henridf","mccanne","mattnibs"]|}\n{user:"henridf",reviewers:|["nwt","aswan","mccanne"]|}\n{user:"mattnibs",reviewers:|["aswan","mccanne"]|}\n{user:"mattnibs",reviewers:|["aswan","henridf"]|}\n...\n')),(0,s.kt)("p",null,'The final step is to simply aggregate the "reviewer sets" with the ',(0,s.kt)("inlineCode",{parentName:"p"},"user")," field\nas the group-by key:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -Z 'over requested_reviewers with user=user.login => ( reviewers:=union(login) | {user,reviewers} ) | groups:=union(reviewers) by user | sort user,len(groups)' prs.zng\n")),(0,s.kt)("p",null,"and we get"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n    user: "aswan",\n    groups: |[\n        |[\n            "mccanne"\n        ]|,\n        |[\n            "nwt",\n            "mccanne"\n        ]|,\n        |[\n            "nwt",\n            "henridf",\n            "mccanne"\n        ]|,\n        |[\n            "henridf",\n            "mccanne",\n            "mattnibs"\n        ]|\n    ]|\n}\n{\n    user: "henridf",\n    groups: |[\n        |[\n            "nwt",\n            "aswan",\n            "mccanne"\n        ]|\n    ]|\n}\n{\n    user: "mattnibs",\n    groups: |[\n        |[\n            "aswan",\n            "henridf"\n        ]|,\n        |[\n            "aswan",\n            "mccanne"\n        ]|,\n        |[\n            "aswan",\n            "henridf",\n            "mccanne"\n        ]|,\n        |[\n            "nwt",\n            "aswan",\n            "henridf",\n            "mccanne"\n        ]|,\n        |[\n            "nwt",\n            "aswan",\n            "mccanne",\n            "mikesbrown"\n        ]|,\n        |[\n            "nwt",\n            "aswan",\n            "philrz",\n            "henridf",\n            "mccanne"\n        ]|\n    ]|\n}\n{\n    user: "mccanne",\n    groups: |[\n        |[\n            "nwt"\n        ]|,\n        |[\n            "aswan"\n        ]|,\n        |[\n            "mattnibs"\n        ]|\n    ]|\n}\n{\n    user: "nwt",\n    groups: |[\n        |[\n            "aswan"\n        ]|,\n        |[\n            "aswan",\n            "mattnibs"\n        ]|,\n        |[\n            "henridf",\n            "mattnibs"\n        ]|,\n        |[\n            "mccanne",\n            "mattnibs"\n        ]|\n    ]|\n}\n')),(0,s.kt)("p",null,"After a quick glance here, you can tell that ",(0,s.kt)("inlineCode",{parentName:"p"},"mccanne")," looks for\nvery targeted reviews while ",(0,s.kt)("inlineCode",{parentName:"p"},"mattnibs")," casts a wide net, at least\nfor the PRs from the beginning of the ",(0,s.kt)("inlineCode",{parentName:"p"},"zed")," repo."),(0,s.kt)("p",null,"To quantify this concept, we can easily modify this query to compute\nthe average number of reviewers requested instead of the set of groups\nof reviewers.  To do this, we just average the reviewer set size\nwith an aggregation:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -z 'over requested_reviewers with user=user.login => ( reviewers:=union(login) | {user,reviewers} ) | avg_reviewers:=avg(len(reviewers)) by user | sort avg_reviewers' prs.zng\n")),(0,s.kt)("p",null,"which produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{user:"mccanne",avg_reviewers:1.}\n{user:"nwt",avg_reviewers:1.75}\n{user:"aswan",avg_reviewers:2.4}\n{user:"mattnibs",avg_reviewers:2.9}\n{user:"henridf",avg_reviewers:3.}\n')),(0,s.kt)("p",null,"Of course, if you'd like the query output in JSON, you can just say ",(0,s.kt)("inlineCode",{parentName:"p"},"-f json")," and\n",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," will happily format the Zed sets as JSON arrays, e.g.,"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"dir=docs/tutorials",dir:"docs/tutorials"},"zq -f json 'over requested_reviewers with user=user.login => ( reviewers:=union(login) | {user,reviewers} ) | groups:=union(reviewers) by user | sort user,len(groups)' prs.zng\n")),(0,s.kt)("p",null,"produces"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{"user":"aswan","groups":[["mccanne"],["nwt","mccanne"],["nwt","henridf","mccanne"],["henridf","mccanne","mattnibs"]]}\n{"user":"henridf","groups":[["nwt","aswan","mccanne"]]}\n{"user":"mattnibs","groups":[["aswan","henridf"],["aswan","mccanne"],["aswan","henridf","mccanne"],["nwt","aswan","henridf","mccanne"],["nwt","aswan","mccanne","mikesbrown"],["nwt","aswan","philrz","henridf","mccanne"]]}\n{"user":"mccanne","groups":[["nwt"],["aswan"],["mattnibs"]]}\n{"user":"nwt","groups":[["aswan"],["aswan","mattnibs"],["henridf","mattnibs"],["mccanne","mattnibs"]]}\n')),(0,s.kt)("h2",{id:"key-takeaways"},"Key Takeaways"),(0,s.kt)("p",null,"So to summarize, we gave you a tour here of ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," and how the Zed data model\nprovide a powerful way do search, transformation, and analytics in a structured-like\nway on data that begins its life as semi-structured JSON and is transformed\ninto the powerful super-structured format without having to create relational\ntables and schemas."),(0,s.kt)("p",null,"As you can see, ",(0,s.kt)("inlineCode",{parentName:"p"},"zq")," is a general-purpose tool that you can add to your bag\nof tricks to:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"explore messy and confusing JSON data using shaping and sampling,"),(0,s.kt)("li",{parentName:"ul"},"transform JSON data in ad hoc ways, and"),(0,s.kt)("li",{parentName:"ul"},"develop transform logic for hitting APIs like the GitHub API to produce\nclean data for analysis by ",(0,s.kt)("inlineCode",{parentName:"li"},"zq")," or even export into other systems or for testing.")),(0,s.kt)("p",null,"If you'd like to learn more, feel free to read through the\n",(0,s.kt)("a",{parentName:"p",href:"/docs/next/language/"},"language docs")," in depth\nor see how you can organize ",(0,s.kt)("a",{parentName:"p",href:"/docs/next/commands/zed"},"Zed data into a lake"),"\nusing a git-like commit model."))}c.isMDXComponent=!0}}]);