"use strict";(self.webpackChunkzed_docs=self.webpackChunkzed_docs||[]).push([[2405],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9884:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={sidebar_position:0,sidebar_label:"zq",description:"A command-line tool that uses the Zed Language for pipeline-style search and analytics."},s="zq",p={unversionedId:"commands/zq",id:"commands/zq",title:"zq",description:"A command-line tool that uses the Zed Language for pipeline-style search and analytics.",source:"@site/docs/commands/zq.md",sourceDirName:"commands",slug:"/commands/zq",permalink:"/docs/next/commands/zq",editUrl:"https://github.com/brimdata/zed/tree/main/docs/commands/zq.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0,sidebar_label:"zq",description:"A command-line tool that uses the Zed Language for pipeline-style search and analytics."},sidebar:"tutorialSidebar",previous:{title:"Commands",permalink:"/docs/next/commands/"},next:{title:"zed",permalink:"/docs/next/commands/zed"}},d={},u=[{value:"1. Usage",id:"1-usage",level:2},{value:"2. Input Formats",id:"2-input-formats",level:2},{value:"2.1 Hard-wired Input Format",id:"21-hard-wired-input-format",level:3},{value:"2.2 Auto-detection",id:"22-auto-detection",level:3},{value:"2.3 ZSON-JSON Auto-detection",id:"23-zson-json-auto-detection",level:3},{value:"3. Output Formats",id:"3-output-formats",level:2},{value:"3.1 Output Format Selection",id:"31-output-format-selection",level:3},{value:"3.2 ZSON Pretty Printing",id:"32-zson-pretty-printing",level:3},{value:"3.3 Pipeline-friendly ZNG",id:"33-pipeline-friendly-zng",level:3},{value:"3.4 Schema-rigid Outputs",id:"34-schema-rigid-outputs",level:3},{value:"3.4.1 Fusing Schemas",id:"341-fusing-schemas",level:4},{value:"3.4.2 Splitting Schemas",id:"342-splitting-schemas",level:4},{value:"4. Query Debugging",id:"4-query-debugging",level:2},{value:"5. Error Handling",id:"5-error-handling",level:2},{value:"6. Examples",id:"6-examples",level:2},{value:"7. Performance",id:"7-performance",level:2},{value:"7.1 Fast Pattern Matching",id:"71-fast-pattern-matching",level:3},{value:"7.2 Efficient JSON Processing",id:"72-efficient-json-processing",level:3},{value:"7.3 Performance Comparisons",id:"73-performance-comparisons",level:3},{value:"7.3.1 Test Data",id:"731-test-data",level:4},{value:"7.3.2 File Sizes",id:"732-file-sizes",level:4},{value:"7.3.3 Tests",id:"733-tests",level:4},{value:"7.3.4 Results",id:"734-results",level:4}],m={toc:u};function c(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"zq"},"zq"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"TL;DR")," ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," is a command-line tool that uses the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/"},"Zed language"),"\nfor pipeline-style search and analytics.  ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," can query a variety\nof data formats in files, over HTTP, or in S3 storage.\nIt is particularly fast when operating on data in the Zed-native ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zng"},"ZNG")," format."),(0,i.kt)("p",{parentName:"blockquote"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," design philosophy blends the query/search-tool approach\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"jq"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"awk"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"grep")," with the command-line, embedded database approach\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"duckdb"),".")),(0,i.kt)("h2",{id:"1-usage"},"1. Usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zq [ options ] [ query ] input [ input ... ]\nzq [ options ] query\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"zq")," is a command-line tool for processing data in diverse input\nformats, providing search, analytics, and extensive transformations\nusing the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/"},"Zed language"),". A query typically applies Boolean logic\nor keyword search to filter the input, then transforms or analyzes\nthe filtered stream.  Output is written to one or more files or to\nstandard output."),(0,i.kt)("p",null,"Each ",(0,i.kt)("inlineCode",{parentName:"p"},"input")," argument must be a file path, an HTTP or HTTPS URL,\nan S3 URL, or standard input specified with ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),"."),(0,i.kt)("p",null,"For built-in command help and a listing of all available options,\nsimply run ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," with no arguments."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"zq")," supports a ",(0,i.kt)("a",{parentName:"p",href:"#2-input-formats"},"number of formats")," but ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zng"},"ZNG"),"\ntends to be the most space-efficient and most performant.  ZNG has efficiency similar to\n",(0,i.kt)("a",{parentName:"p",href:"https://avro.apache.org/docs/current/spec.html"},"Avro"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers"},"Protocol Buffers"),"\nbut its comprehensive ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/formats/zed"},"Zed type system")," obviates\nthe need for schema specification or registries.\nAlso, the ZSON format is human-readable and entirely one-to-one with ZNG\nso there is no need to represent non-readable formats like Avro or Protocol Buffers\nin a clunky JSON encapsulated form.  "),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"zq")," typically operates on ZNG-encoded data and when you want to inspect\nhuman-readable bits of output, you merely format it as ZSON, which is the\ndefault format when output is directed to the terminal.  ZNG is the default\nwhen redirecting to a non-terminal output like a file or pipe."),(0,i.kt)("p",null,"When run with input arguments, each input's format is automatically inferred\n(",(0,i.kt)("a",{parentName:"p",href:"#22-auto-detection"},"as described below"),") and each input is scanned\nin the order appearing on the command line forming the input stream."),(0,i.kt)("p",null,"A query expressed in the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/"},"Zed language"),"\nmay be optionally specified and applied to the input stream."),(0,i.kt)("p",null,"If no query is specified, the inputs are scanned without modification\nand output in the desired format as described below.  This latter approach\nprovides a convenient means to convert files from one format to another."),(0,i.kt)("p",null,"To determine whether the first argument is a query or an input,\n",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," checks the local file system for the existence of a file by that name\nor whether the name is an URL.\nIf no such file or URL exists, it attempts to parse the text as a Zed program.\nIf both checks fail, then an error is reported and ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," exits."),(0,i.kt)("p",null,"This heuristic is convenient but can result in a rare surprise when a simple\nZed query (like a keyword search) happens to correspond with a file of the\nsame name in the local directory.\nTo avoid this, you can provide the query with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-query")," flag, which specifies\nthe Zed program to run and forces all arguments to be interpreted as inputs."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," is run with a query and no input arguments, then the query must\nbegin with a"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a ",(0,i.kt)("a",{parentName:"li",href:"/docs/next/language/operators/from"},"from, file, or get operator"),", or"),(0,i.kt)("li",{parentName:"ul"},"an explicit or implied ",(0,i.kt)("a",{parentName:"li",href:"/docs/next/language/operators/yield"},"yield operator"),".")),(0,i.kt)("p",null,"In the case of a ",(0,i.kt)("inlineCode",{parentName:"p"},"yield")," with no inputs, the query is run with\na single input value of ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),'.  This provides a convenient means to run in a\n"calculator mode" where input is produced by the yield and can be operated upon\nby the Zed query, e.g.,'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"zq -z '1+1'\n")),(0,i.kt)("p",null,"emits"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"2\n")),(0,i.kt)("p",null,"Note here that the query ",(0,i.kt)("inlineCode",{parentName:"p"},"1+1")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/overview#26-implied-operators"},"implies"),"\n",(0,i.kt)("inlineCode",{parentName:"p"},"yield 1+1"),"."),(0,i.kt)("h2",{id:"2-input-formats"},"2. Input Formats"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"zq")," currently supports the following input formats:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Option"),(0,i.kt)("th",{parentName:"tr",align:null},"Auto"),(0,i.kt)("th",{parentName:"tr",align:null},"Specification"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"json")),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"https://www.rfc-editor.org/rfc/rfc8259.html"},"JSON RFC 8259"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"csv")),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"https://www.rfc-editor.org/rfc/rfc4180.html"},"CSV RFC 4180"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"parquet")),(0,i.kt)("td",{parentName:"tr",align:null},"no"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"https://github.com/apache/parquet-format"},"Apache Parquet"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zson")),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/docs/next/formats/zson"},"ZSON - Human-readable Format"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zng")),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/docs/next/formats/zson"},"ZNG - Binary Row Format"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zst")),(0,i.kt)("td",{parentName:"tr",align:null},"no"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/docs/next/formats/zst"},"ZST - Binary Columnar Format"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zjson")),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"/docs/next/formats/zjson"},"ZJSON - Zed over JSON"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zeek")),(0,i.kt)("td",{parentName:"tr",align:null},"yes"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("a",{parentName:"td",href:"https://docs.zeek.org/en/master/logs/index.html"},"Zeek Logs"))))),(0,i.kt)("p",null,"The input format is typically detected automatically and the formats for which\n",(0,i.kt)("inlineCode",{parentName:"p"},"Auto")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"yes")," in the table above support ",(0,i.kt)("em",{parentName:"p"},"auto detection"),".\nFormats without auto detection require the ",(0,i.kt)("inlineCode",{parentName:"p"},"-i")," option."),(0,i.kt)("h3",{id:"21-hard-wired-input-format"},"2.1 Hard-wired Input Format"),(0,i.kt)("p",null,"The input format is specified with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-i")," flag."),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"-i")," is specified, all of the inputs on the command-line must be\nin the indicated format."),(0,i.kt)("h3",{id:"22-auto-detection"},"2.2 Auto-detection"),(0,i.kt)("p",null,"When using ",(0,i.kt)("em",{parentName:"p"},"auto detection"),", each input's format is independently determined\nso it is possible to easily blend different input formats into a unified\noutput format."),(0,i.kt)("p",null,"For example, suppose this content is in a file ",(0,i.kt)("inlineCode",{parentName:"p"},"sample.csv"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-input",metastring:"sample.csv","sample.csv":!0},"a,b\n1,foo\n2,bar\n")),(0,i.kt)("p",null,"and this content is in ",(0,i.kt)("inlineCode",{parentName:"p"},"sample.json")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-input",metastring:"sample.json","sample.json":!0},'{"a":3,"b":"baz"}\n')),(0,i.kt)("p",null,"then the command"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"zq -z sample.csv sample.json\n")),(0,i.kt)("p",null,"would produce this output in the default ZSON format"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{a:1.,b:"foo"}\n{a:2.,b:"bar"}\n{a:3,b:"baz"}\n')),(0,i.kt)("h3",{id:"23-zson-json-auto-detection"},"2.3 ZSON-JSON Auto-detection"),(0,i.kt)("p",null,"Since ZSON is a superset of JSON, ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," must be careful in whether it\ninterprets input as ZSON as JSON.  While you can always clarify your intent\nwith the ",(0,i.kt)("inlineCode",{parentName:"p"},"-i zson")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"-i json"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"zq"),' attempts to "just do the right thing"\nwhen you run it with JSON vs. ZSON.'),(0,i.kt)("p",null,"While ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," can parse any JSON using its built-in ZSON parser this is typically\nnot desirable because (1) the ZSON parser is not particularly performant and\n(2) all JSON numbers are floating point but the ZSON parser will parse as\nJSON any number that appears without a decimal point as an integer type."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The reason ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," is not particularly performant for ZSON is that the ZNG or\nZST formats are semantically equivalent to ZSON but much more efficient and\nthe design intent is that these efficient binary formats should be used in\nuse cases where performance matters.  ZSON is typically used only when\ndata needs to be human-readable in interactive settings or in automated tests.")),(0,i.kt)("p",null,"To this end, ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," uses a heuristic to select between ZSON in JSON when the\n",(0,i.kt)("inlineCode",{parentName:"p"},"-i")," option is not specified. Specifically, JSON is selected when the first values\nof the input are parsable as valid JSON and includes a JSON object either\nas an outer object or as a value nested somewhere within a JSON array."),(0,i.kt)("p",null,"This heuristic almost always works in practice because ZSON records\ntypically omit quotes around field names."),(0,i.kt)("h2",{id:"3-output-formats"},"3. Output Formats"),(0,i.kt)("p",null,"The output format defaults to either ZSON or ZNG and may be specified\nwith the ",(0,i.kt)("inlineCode",{parentName:"p"},"-f")," option.  The supported output formats include all of\nthe input formats along with text and table formats, which are useful\nfor displaying data.  (They do not capture all the information required\nto reconstruct the original data so they are not supported input formats.)"),(0,i.kt)("p",null,"Since ZSON is a common format choice, the ",(0,i.kt)("inlineCode",{parentName:"p"},"-z")," flag is a shortcut for\n",(0,i.kt)("inlineCode",{parentName:"p"},"-f zson."),"  Also, ",(0,i.kt)("inlineCode",{parentName:"p"},"-Z")," is a shortcut for ",(0,i.kt)("inlineCode",{parentName:"p"},"-f zson")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"-pretty 4")," as\ndescribed below."),(0,i.kt)("p",null,"And since JSON is another common format choice, the ",(0,i.kt)("inlineCode",{parentName:"p"},"-j")," flag is a shortcut for\n",(0,i.kt)("inlineCode",{parentName:"p"},"-f json.")),(0,i.kt)("h3",{id:"31-output-format-selection"},"3.1 Output Format Selection"),(0,i.kt)("p",null,"When the format is not specified with ",(0,i.kt)("inlineCode",{parentName:"p"},"-f"),", it defaults to ZSON if the output\nis a terminal and to ZNG otherwise."),(0,i.kt)("p",null,"While this can cause an occasional surprise (e.g., forgetting ",(0,i.kt)("inlineCode",{parentName:"p"},"-f")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"-z"),"\nin a scripted test that works fine on the command line but fails in CI),\nwe felt that the design of having a uniform default had worse consequences:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the default format were ZSON, it would be very easy to create pipelines\nand deploy to production systems that were accidentally using ZSON instead of\nthe much more efficient ZNG format because the ",(0,i.kt)("inlineCode",{parentName:"li"},"-f zng"),' had been mistakenly\nomitted from some command.  The beauty of Zed is that all of this "just works"\nbut it would otherwise perform poorly.'),(0,i.kt)("li",{parentName:"ul"},"If the default format were ZNG, then users would be endlessly annoyed by\nbinary output to their terminal when forgetting to type ",(0,i.kt)("inlineCode",{parentName:"li"},"-f zson"),".")),(0,i.kt)("p",null,'In practice, we have found that the output defaults\n"just do the right thing" almost all of the time.'),(0,i.kt)("h3",{id:"32-zson-pretty-printing"},"3.2 ZSON Pretty Printing"),(0,i.kt)("p",null,'ZSON text may be "pretty printed" with the ',(0,i.kt)("inlineCode",{parentName:"p"},"-pretty")," option, which takes\nthe number of spaces to use for indentation.  As this is a common option,\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"-Z")," option is a shortcut for ",(0,i.kt)("inlineCode",{parentName:"p"},"-f zson -pretty 4"),"."),(0,i.kt)("p",null,"For example,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{a:{b:1,c:[1,2]},d:\"foo\"}' | zq -Z -\n")),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n    a: {\n        b: 1,\n        c: [\n            1,\n            2\n        ]\n    },\n    d: "foo"\n}\n')),(0,i.kt)("p",null,"and"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{a:{b:1,c:[1,2]},d:\"foo\"}' | zq -f zson -pretty 2 -\n")),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n  a: {\n    b: 1,\n    c: [\n      1,\n      2\n    ]\n  },\n  d: "foo"\n}\n')),(0,i.kt)("p",null,"When pretty printing, colorization is enabled by default when writing to a terminal,\nand can be disabled with ",(0,i.kt)("inlineCode",{parentName:"p"},"-color false"),"."),(0,i.kt)("h3",{id:"33-pipeline-friendly-zng"},"3.3 Pipeline-friendly ZNG"),(0,i.kt)("p",null,"Though it's a compressed binary format, ZNG data is self-describing and stream-oriented\nand thus is pipeline friendly."),(0,i.kt)("p",null,'Since data is self-describing you can simply take ZNG output\nof one command and pipe it to the input of another.  It doesn\'t matter if the value\nsequence is scalars, complex types, or records.  There is no need to declare\nor register schemas or "protos" with the downstream entities.'),(0,i.kt)("p",null,"In particular, ZNG data can simply be concatenated together, e.g.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"zq -f zng 'yield 1,[1,2,3]' > a.zng\nzq -f zng 'yield {s:\"hello\"},{s:\"world\"}' > b.zng\ncat a.zng b.zng | zq -z -\n")),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'1\n[1,2,3]\n{s:"hello"}\n{s:"world"}\n')),(0,i.kt)("p",null,"And while this ZSON output is human readable, the ZNG files are binary, e.g.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"zq -f zng 'yield 1,[1,2,3]' > a.zng\nhexdump -C a.zng\n")),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"00000000  02 00 01 09 1b 00 09 02  02 1e 07 02 02 02 04 02  |................|\n00000010  06 ff                                             |..|\n00000012\n")),(0,i.kt)("h3",{id:"34-schema-rigid-outputs"},"3.4 Schema-rigid Outputs"),(0,i.kt)("p",null,'Certain data formats like Parquet are "schema rigid" in the sense that they\nrequire a schema to be defined before values can be written into the file and\nall the values in the file must conform to this schema.'),(0,i.kt)("p",null,"Zed, however, has a fine-grained type system instead of schemas and a sequence\nof data values are completely self-describing and may be heterogeneous in nature.\nThis creates a challenge converting the type-flexible Zed formats to a schema-rigid\nformat like Parquet."),(0,i.kt)("p",null,"For example, this seemingly simple conversion:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command",metastring:"fails",fails:!0},"echo '{x:1}{s:\"hello\"}' | zq -o out.parquet -f parquet -\n")),(0,i.kt)("p",null,"causes this error"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"Parquet output requires uniform records but multiple types encountered (consider 'fuse')\n")),(0,i.kt)("h4",{id:"341-fusing-schemas"},"3.4.1 Fusing Schemas"),(0,i.kt)("p",null,"As suggested by the error above, the Zed ",(0,i.kt)("inlineCode",{parentName:"p"},"fuse")," operator can merge different record\ntypes into a blended type, e.g., here we create the file and read it back:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{x:1}{s:\"hello\"}' | zq -o out.parquet -f parquet fuse -\nzq -z -i parquet out.parquet\n")),(0,i.kt)("p",null,"but the data was necessarily changed (by inserting nulls):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{x:1,s:null(string)}\n{x:null(int64),s:"hello"}\n')),(0,i.kt)("h4",{id:"342-splitting-schemas"},"3.4.2 Splitting Schemas"),(0,i.kt)("p",null,"Another common approach to dealing with the schema-rigid limitation of Parquet\nis to create a separate file for each schema."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"zq")," can do this too with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-split")," option, which specifies a path\nto a directory for the output files.  If the path is ",(0,i.kt)("inlineCode",{parentName:"p"},"."),", then files\nare written to the current directory."),(0,i.kt)("p",null,"The files are named using the ",(0,i.kt)("inlineCode",{parentName:"p"},"-o")," option as a prefix and the suffix is\n",(0,i.kt)("inlineCode",{parentName:"p"},"-<n>.<ext>")," where the ",(0,i.kt)("inlineCode",{parentName:"p"},"<ext>")," is determined from the output format and\nwhere ",(0,i.kt)("inlineCode",{parentName:"p"},"<n>")," is a unique integer for each distinct output file."),(0,i.kt)("p",null,"For example, the example above would produce two output files,\nwhich can then be read separately to reproduce the original data, e.g.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{x:1}{s:\"hello\"}' | zq -o out -split . -f parquet -\nzq -z -i parquet out-*.parquet\n")),(0,i.kt)("p",null,"produces the original data"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{x:1}\n{s:"hello"}\n')),(0,i.kt)("p",null,"While the ",(0,i.kt)("inlineCode",{parentName:"p"},"-split")," option is most useful for schema-rigid formats, it can\nbe used with any output format."),(0,i.kt)("h2",{id:"4-query-debugging"},"4. Query Debugging"),(0,i.kt)("p",null,"If you are ever stumped about how the ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," compiler is parsing your query,\nyou can always run ",(0,i.kt)("inlineCode",{parentName:"p"},"zq -C")," to compile and display your query in canonical form\nwithout running it.\nThis can be especially handy when you are learning the language and\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/overview#26-implied-operators"},"its shortcuts"),"."),(0,i.kt)("p",null,"For example, this query"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"zq -C 'has(foo)'\n")),(0,i.kt)("p",null,"is an implied ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/operators/where"},"where operator"),", which matches values\nthat have a field ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),", i.e.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"where has(foo)\n")),(0,i.kt)("p",null,"while this query"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"zq -C 'lower(foo)'\n")),(0,i.kt)("p",null,"is an implied ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/operators/yield"},"yield operator"),", which produces the lower case\nversion of the presumed string in field ",(0,i.kt)("inlineCode",{parentName:"p"},"foo"),", i.e.,"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"yield lower(foo)\n")),(0,i.kt)("h2",{id:"5-error-handling"},"5. Error Handling"),(0,i.kt)("p",null,'Fatal errors like "file not found" or "file system full" are reported\nas soon as they happen and cause the ',(0,i.kt)("inlineCode",{parentName:"p"},"zq")," process to exit."),(0,i.kt)("p",null,"On the other hand,\nruntime errors resulting from the Zed query itself\ndo not halt execution.  Instead, these error conditions produce\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/overview#53-first-class-errors"},"first-class Zed errors"),"\nin the data output stream interleaved with any valid results.\nSuch errors are easily queried with the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/functions/is_error"},"is_error function"),"."),(0,i.kt)("p",null,"This approach provides a robust technique for debugging complex query pipelines,\nwhere errors can be wrapped in one another providing stack-trace-like debugging\noutput alongside the output data.  This approach has emerged as a more powerful\nalternative to the traditional technique of looking through logs for errors\nor trying to debug a halted program with a vague error message."),(0,i.kt)("p",null,"For example, this query"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"echo '1 2 0 3' |  zq '10.0/this' -\n")),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'10.\n5.\nerror("divide by zero")\n3.3333333333333335\n')),(0,i.kt)("p",null,"and"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"echo '1 2 0 3' |  zq '10.0/this' - | zq 'is_error(this)' -\n")),(0,i.kt)("p",null,"produces just"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'error("divide by zero")\n')),(0,i.kt)("h2",{id:"6-examples"},"6. Examples"),(0,i.kt)("p",null,"As you may have noticed, many examples of the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/"},"Zed language"),"\nare illustrated using this pattern"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"echo <values> | zq <query> -\n")),(0,i.kt)("p",null,"which is used throughout the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/"},"language documentation"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/language/operators/"},"operator reference"),"."),(0,i.kt)("p",null,"The language documentation and ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/tutorials/"},"tutorials directory"),"\nhave many examples, but here are a few more simple ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," use cases."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Hello, world")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"echo '\"hello, world\"' | zq -z 'yield this' -\n")),(0,i.kt)("p",null,"produces this ZSON output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"hello, world"\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Some values of available data types")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'echo \'1 1.5 [1,"foo"] |["apple","banana"]|\' | zq -z \'yield this\' -\n')),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'1\n1.5\n[1,"foo"]\n|["apple","banana"]|\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"The types of various data")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'echo \'1 1.5 [1,"foo"] |["apple","banana"]|\' | zq -z \'yield typeof(this)\' -\n')),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<int64>\n<float64>\n<[(int64,string)]>\n<|[string]|>\n")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"A simple aggregation")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'echo \'{key:"foo",val:1}{key:"bar",val:2}{key:"foo",val:3}\' | zq -z \'sum(val) by key | sort key\' -\n')),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{key:"bar",sum:2}\n{key:"foo",sum:4}\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Convert CSV to Zed and cast a to an integer from default float")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"printf \"a,b\\n1,foo\\n2,bar\\n\" | zq 'a:=int64(a)' -\n")),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{a:1,b:"foo"}\n{a:2,b:"bar"}\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Convert JSON to Zed and cast to an integer from default float")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'echo \'{"a":1,"b":"foo"}{"a":2,"b":"bar"}\' | zq \'a:=int64(a)\' -\n')),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{a:1,b:"foo"}\n{a:2,b:"bar"}\n')),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Make a schema-rigid Parquet file using fuse and turn it back into Zed")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"echo '{a:1}{a:2}{b:3}' | zq -f parquet -o tmp.parquet fuse -\nzq -z -i parquet tmp.parquet\n")),(0,i.kt)("p",null,"produces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"{a:1,b:null(int64)}\n{a:2,b:null(int64)}\n{a:null(int64),b:3}\n")),(0,i.kt)("h2",{id:"7-performance"},"7. Performance"),(0,i.kt)("p",null,"Your mileage may vary, but many new users of ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," are surprised by its speed\ncompared to tools like ",(0,i.kt)("inlineCode",{parentName:"p"},"jq"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"grep"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"awk"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite")," especially when running\n",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," over files in the ZNG format."),(0,i.kt)("h3",{id:"71-fast-pattern-matching"},"7.1 Fast Pattern Matching"),(0,i.kt)("p",null,"One important technique that helps ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," run fast is to take advantage of queries\nthat involve fine-grained searches."),(0,i.kt)("p",null,'When a query begins with a logical expression containing either a search\nor a predicate match with a constant value, and presuming the input data format\nis ZNG, then the runtime optimizes the query by performing an efficient,\nbyte-oriented "pre-search" of the values required in the predicate.  This pre-search\nscans the bytes that comprise a large buffer of values and looks for these values\nand, if they are not present, the entire buffer is discarded knowing no individual\nvalue in that buffer could match because the required serialized\nvalues were not present in the buffer.'),(0,i.kt)("p",null,"For example, if the Zed query is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'"http error" and ipsrc==10.0.0.1 | count()\n')),(0,i.kt)("p",null,'then the pre-search would look for the string "http error" and the Zed encoding\nof the IP address 10.0.0.1 and unless both those values are present, then the\nbuffer is discarded.'),(0,i.kt)("p",null,"Moreover, ZNG data is compressed and arranged into frames that can be decompressed\nand processed in parallel.  This allows the decompression and pre-search to\nrun in parallel very efficiently across a large number of threads.  When searching\nfor sparse results, many frames are discarded without their uncompressed bytes\nhaving to be processed any further."),(0,i.kt)("p",null,"While this pre-search technique results in very fast brute-force pattern matching,\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/commands/zed#16-search-indexes"},"search indexes"),"\ncan also be created when Zed data is managed by a Zed lake\nthereby avoiding scans of data altogether as the index pinpoints the locations\nof specific values in the lake."),(0,i.kt)("h3",{id:"72-efficient-json-processing"},"7.2 Efficient JSON Processing"),(0,i.kt)("p",null,"While processing data in the ZNG format is far more efficient than JSON,\nthere is substantial JSON data in the world and it is important for JSON\ninput to perform well."),(0,i.kt)("p",null,"This proved a challenge as ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," is written in Go and Go's JSON package\nis not particularly performant.  To this end, ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," has its own lean and simple\n",(0,i.kt)("a",{parentName:"p",href:"https://pkg.go.dev/github.com/brimdata/zed/pkg/jsonlexer"},"JSON tokenizer"),",\nwhich performs quite well,\nand is\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/brimdata/zed/blob/main/zio/jsonio/reader.go"},"integrated tightly"),"\nwith Zed's internal data representation.\nMoreover, like ",(0,i.kt)("inlineCode",{parentName:"p"},"jq"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"zq"),"'s JSON parser does not require objects to be newline delimited and can\nincrementally parse the input to minimize memory overhead and improve\nprocessor cache performance."),(0,i.kt)("p",null,"The net effect is a JSON parser that is typically a bit faster than the\nnative C implementation in ",(0,i.kt)("inlineCode",{parentName:"p"},"jq"),"."),(0,i.kt)("h3",{id:"73-performance-comparisons"},"7.3 Performance Comparisons"),(0,i.kt)("p",null,"To provide a rough sense of the performance tradeoffs between ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," and\nother tooling, this section provides results of a few simple speed tests."),(0,i.kt)("h4",{id:"731-test-data"},"7.3.1 Test Data"),(0,i.kt)("p",null,"These tests are easy to reproduce.  The input data comes from the\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/brimdata/zed-sample-data"},"Zed sample data repository"),',\nwhere we used a semi-structured Zeek "conn" log from the ',(0,i.kt)("inlineCode",{parentName:"p"},"zeek-default")," directory."),(0,i.kt)("p",null,"It is easy to convert the Zeek logs to a local ZNG file using\nzq's built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zq -o conn.zng 'get https://raw.githubusercontent.com/brimdata/zed-sample-data/main/zeek-default/conn.log.gz'\n")),(0,i.kt)("p",null,"This creates a new file ",(0,i.kt)("inlineCode",{parentName:"p"},"conn.zng")," from the Zeek log file fetched from GitHub."),(0,i.kt)("p",null,"Note that this data is a gzip'd file in the Zeek format and ",(0,i.kt)("inlineCode",{parentName:"p"},"zq"),"'s auto-detector\nfigures out both that it is gzip'd and that the uncompressed format is Zeek.\nThere's no need to specify flags for this."),(0,i.kt)("p",null,"Next, a JSON file can be converted from ZNG using:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"zq -f json conn.zng > conn.json\n")),(0,i.kt)("p",null,"Note here that we lose information in this conversion because the rich data types\nof Zed (that were ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/brimdata/zed/blob/main/zeek/Data-Type-Compatibility.md"},"translated from the Zeek format"),") are lost."),(0,i.kt)("p",null,"We'll also make a SQLite database in the file ",(0,i.kt)("inlineCode",{parentName:"p"},"conn.db")," as the table named ",(0,i.kt)("inlineCode",{parentName:"p"},"conn"),".\nOne easy way to do this is to install\n",(0,i.kt)("a",{parentName:"p",href:"https://sqlite-utils.datasette.io/en/stable/"},"sqlite-utils"),"\nand run"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"sqlite-utils insert conn.db conn conn.json --nl\n")),(0,i.kt)("p",null,"(If you need a cup of coffee, a good time to get it would be when\nloading the JSON into SQLite.)"),(0,i.kt)("h4",{id:"732-file-sizes"},"7.3.2 File Sizes"),(0,i.kt)("p",null,"Note the resulting file sizes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"% du -h conn.json conn.db conn.zng\n416M    conn.json\n192M    conn.db\n 38M    conn.zng\n")),(0,i.kt)("p",null,"Much of the performance of ZNG derives from an efficient, parallelizable\nstructure where frames of data are compressed\n(currently with ",(0,i.kt)("a",{parentName:"p",href:"http://lz4.github.io/lz4/"},"LZ4")," though the\nspecification supports multiple algorithms) and the sequence of values\ncan be processed with only partial deserialization."),(0,i.kt)("p",null,"That said, there are quite a few more opportunities to further improve\nthe performance of ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," and the Zed system and we have a number of projects\nforthcoming on this front."),(0,i.kt)("h4",{id:"733-tests"},"7.3.3 Tests"),(0,i.kt)("p",null,"We ran three styles of tests on a Mac quad-core 2.3GHz i7:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"count")," - compute the number of values present"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"search")," - find a value in a field"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"agg")," - sum a field grouped by another field")),(0,i.kt)("p",null,"Each test was run for ",(0,i.kt)("inlineCode",{parentName:"p"},"jq"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," on JSON, ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite3"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," on ZNG."),(0,i.kt)("p",null,"We used the Bash ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," command to measure elapsed time."),(0,i.kt)("p",null,"The command lines for the ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," test were:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"jq -s length conn.json\nsqlite3 conn.db 'select count(*) from conn'\nzq 'count()' conn.zng\nzq 'count()' conn.json\n")),(0,i.kt)("p",null,"The command lines for the ",(0,i.kt)("inlineCode",{parentName:"p"},"search")," test were:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"jq 'select(.id.orig_h==\"10.47.23.5\")' conn.json\nsqlite3 conn.db 'select * from conn where json_extract(id, \"$.orig_h\")==\"10.47.23.5\"'\nzq 'id.orig_h==10.47.23.5' conn.zng\nzq 'id.orig_h==10.47.23.5' conn.json\n")),(0,i.kt)("p",null,"Here, we look for an IP address (10.47.23.5) in a specific\nfield ",(0,i.kt)("inlineCode",{parentName:"p"},"id.orig_h")," in the semi-structured data.  Note when using ZNG,\nthe IP is a native type whereas for ",(0,i.kt)("inlineCode",{parentName:"p"},"jq")," and SQLite it is a string.\nNote that ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite")," must use its ",(0,i.kt)("inlineCode",{parentName:"p"},"json_extract")," function since nested JSON objects\nare stored as minified JSON text."),(0,i.kt)("p",null,"The command lines for the ",(0,i.kt)("inlineCode",{parentName:"p"},"agg")," test were:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'jq -n -f agg.jq conn.json\nsqlite3 conn.db \'select sum(orig_bytes),json_extract(id, "$.orig_h") as orig_h from conn group by orig_h\'\nzq "sum(orig_bytes) by id.orig_h" conn.zng\nzq "sum(orig_bytes) by id.orig_h" conn.json\n')),(0,i.kt)("p",null,"where the ",(0,i.kt)("inlineCode",{parentName:"p"},"agg.jq")," script is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"def adder(stream):\n  reduce stream as $s ({}; .[$s.key] += $s.val);\nadder(inputs | {key:.id.orig_h,val:.orig_bytes})\n| to_entries[]\n| {orig_h: (.key), sum: .value}\n")),(0,i.kt)("h4",{id:"734-results"},"7.3.4 Results"),(0,i.kt)("p",null,"The following table summarizes the results of each test as a column and\neach tool as a row with the speed-up factor (relative to ",(0,i.kt)("inlineCode",{parentName:"p"},"jq"),")\nshown in parentheses:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null}),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"th"},"count")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"th"},"search")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"th"},"agg")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"jq")),(0,i.kt)("td",{parentName:"tr",align:null},"11,540ms (1X)"),(0,i.kt)("td",{parentName:"tr",align:null},"10,730ms (1X)"),(0,i.kt)("td",{parentName:"tr",align:null},"20,175ms (1X)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zq-json")),(0,i.kt)("td",{parentName:"tr",align:null},"7,150ms (1.6X)"),(0,i.kt)("td",{parentName:"tr",align:null},"7,230ms (1.5X)"),(0,i.kt)("td",{parentName:"tr",align:null},"7,390ms (2.7X)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sqlite")),(0,i.kt)("td",{parentName:"tr",align:null},"100ms (115X)"),(0,i.kt)("td",{parentName:"tr",align:null},"620ms (17X)"),(0,i.kt)("td",{parentName:"tr",align:null},"1,475ms (14X)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"zq-zng")),(0,i.kt)("td",{parentName:"tr",align:null},"110ms (105X)"),(0,i.kt)("td",{parentName:"tr",align:null},"135ms (80X)"),(0,i.kt)("td",{parentName:"tr",align:null},"475ms (42X)")))),(0,i.kt)("p",null,"To summarize, ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," with ZNG is consistently fastest though ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite"),"\nwas a bit faster counting rows."),(0,i.kt)("p",null,"In particular, ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," is substantially faster (40-100X) than ",(0,i.kt)("inlineCode",{parentName:"p"},"jq")," with the efficient\nZNG format but more modestly faster (50-170%) when processing the bulky JSON input.\nThis is expected because parsing JSON becomes the bottleneck."),(0,i.kt)("p",null,"While SQLite is much faster than ",(0,i.kt)("inlineCode",{parentName:"p"},"jq"),", it is not as fast as ",(0,i.kt)("inlineCode",{parentName:"p"},"zq"),".  The primary\nreason for this is that SQLite stores its semi-structured columns as minified JSON text,\nso it must scan and parse the JSON when executing the ",(0,i.kt)("em",{parentName:"p"},"where")," clause above\nas well as the aggregated fields."),(0,i.kt)("p",null,"Also, note that the inferior performance of ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite")," is in areas where databases\nperform extraordinarily well if you do the work to\n(1) transform semi-structured columns to relational columns by flattening\nnested JSON objects (which are not indexable by ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite"),") and\n(2) configuring database indexes."),(0,i.kt)("p",null,"In fact, if you implement these changes, ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite")," performs better than ",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," on these tests."),(0,i.kt)("p",null,"However, the benefit of Zed is that no flattening is required.  And unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"sqlite"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"zq")," is not intended to be a database.  That said, there is no reason why database\nperformance techniques cannot be applied to the Zed model and this is precisely what the\nopen-source Zed project intends to do.  As a first step, with a\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/commands/zed"},"Zed lake"),", you can build type-flexible\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/commands/zed#16-search-indexes"},"search indexes"),"\nto scale searches across very large stores of Zed data."),(0,i.kt)("p",null,"Stay tuned!"))}c.isMDXComponent=!0}}]);