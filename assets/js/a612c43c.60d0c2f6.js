"use strict";(self.webpackChunkzed_docs=self.webpackChunkzed_docs||[]).push([[5929],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||o;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},663:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={sidebar_position:1,sidebar_label:"Overview"},s="Zed Language Overview",p={unversionedId:"language/overview",id:"version-v1.1.0/language/overview",title:"Zed Language Overview",description:"1. Introduction",source:"@site/versioned_docs/version-v1.1.0/language/overview.md",sourceDirName:"language",slug:"/language/overview",permalink:"/docs/v1.1.0/language/overview",editUrl:"https://github.com/brimdata/zed/edit/main/docs/language/overview.md",tags:[],version:"v1.1.0",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"Overview"},sidebar:"tutorialSidebar",previous:{title:"The Zed Language",permalink:"/docs/v1.1.0/language/"},next:{title:"Conventions",permalink:"/docs/v1.1.0/language/conventions"}},d={},u=[{value:"1. Introduction",id:"1-introduction",level:2},{value:"2. The Dataflow Model",id:"2-the-dataflow-model",level:2},{value:"2.1 Dataflow Sources",id:"21-dataflow-sources",level:3},{value:"2.2 Dataflow Operators",id:"22-dataflow-operators",level:3},{value:"2.3 The Special Value <code>this</code>",id:"23-the-special-value-this",level:3},{value:"2.4 Implied Field References",id:"24-implied-field-references",level:3},{value:"2.5 Field Assignments",id:"25-field-assignments",level:3},{value:"2.6 Implied Operators",id:"26-implied-operators",level:3},{value:"3. Const Statements",id:"3-const-statements",level:2},{value:"4. Type Statements",id:"4-type-statements",level:2},{value:"5. Data Types",id:"5-data-types",level:2},{value:"5.1 First-class Types",id:"51-first-class-types",level:3},{value:"5.2 Named Types",id:"52-named-types",level:3},{value:"5.3 First-class Errors",id:"53-first-class-errors",level:3},{value:"5.3.1 Missing and Quiet",id:"531-missing-and-quiet",level:4},{value:"6. Expressions",id:"6-expressions",level:2},{value:"6.1 Arithmetic",id:"61-arithmetic",level:3},{value:"6.2 Comparisons",id:"62-comparisons",level:3},{value:"6.3 Containment",id:"63-containment",level:3},{value:"6.4 Logic",id:"64-logic",level:3},{value:"6.5 Field Dereference",id:"65-field-dereference",level:3},{value:"6.6 Indexing",id:"66-indexing",level:3},{value:"6.7 Slices",id:"67-slices",level:3},{value:"6.8 Conditional",id:"68-conditional",level:3},{value:"6.9 Function Calls",id:"69-function-calls",level:3},{value:"6.10 Aggregate Function Calls",id:"610-aggregate-function-calls",level:3},{value:"6.11 Literals",id:"611-literals",level:3},{value:"6.11.1 String Interpolation",id:"6111-string-interpolation",level:4},{value:"6.11.2 Record Expressions",id:"6112-record-expressions",level:4},{value:"6.11.3 Array Expressions",id:"6113-array-expressions",level:4},{value:"6.11.4 Set Expressions",id:"6114-set-expressions",level:4},{value:"6.11.5 Map Expressions",id:"6115-map-expressions",level:4},{value:"6.11.6 Union Values",id:"6116-union-values",level:4},{value:"6.12 Constants",id:"612-constants",level:3},{value:"6.13 Type Definitions",id:"613-type-definitions",level:3},{value:"6.14 Casts",id:"614-casts",level:3},{value:"7. Search Expressions",id:"7-search-expressions",level:2},{value:"7.1 Search Patterns",id:"71-search-patterns",level:3},{value:"7.1.1 Regular Expressions",id:"711-regular-expressions",level:4},{value:"7.1.2 Globs",id:"712-globs",level:4},{value:"7.2 Search Logic",id:"72-search-logic",level:3},{value:"7.2.1 Search Terms",id:"721-search-terms",level:4},{value:"7.2.1.1 Regular Expression Search Term",id:"7211-regular-expression-search-term",level:5},{value:"7.2.1.2 Glob Search Term",id:"7212-glob-search-term",level:5},{value:"7.2.1.3 Keyword Search Term",id:"7213-keyword-search-term",level:5},{value:"7.2.1.4 String Literal Search Term",id:"7214-string-literal-search-term",level:5},{value:"7.2.1.5 Non-String Literal Search Term",id:"7215-non-string-literal-search-term",level:5},{value:"7.2.1.6 Predicate Search Term",id:"7216-predicate-search-term",level:5},{value:"7.3 Boolean Logic",id:"73-boolean-logic",level:4},{value:"8. Lateral Subqueries",id:"8-lateral-subqueries",level:2},{value:"8.1 Lateral Scope",id:"81-lateral-scope",level:3},{value:"8.2 Lateral Expressions",id:"82-lateral-expressions",level:3},{value:"9. Shaping",id:"9-shaping",level:2},{value:"9.1 Cast",id:"91-cast",level:3},{value:"9.2 Crop",id:"92-crop",level:3},{value:"9.3 Fill",id:"93-fill",level:3},{value:"9.4 Order",id:"94-order",level:3},{value:"9.5 Shape",id:"95-shape",level:3},{value:"10. Type Fusion",id:"10-type-fusion",level:2},{value:"10.1 Fuse Operator",id:"101-fuse-operator",level:3},{value:"10.2 Fuse Function",id:"102-fuse-function",level:3}],m={toc:u};function c(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"zed-language-overview"},"Zed Language Overview"),(0,o.kt)("h2",{id:"1-introduction"},"1. Introduction"),(0,o.kt)("p",null,"The Zed language is a query language for search, analytics,\nand transformation inspired by the\n",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Tacit_programming"},"pipeline pattern"),"\nof the traditional Unix shell.\nLike a Unix pipeline, a query is expressed as a data source followed\nby a number of commands:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"command | command | command | ...\n")),(0,o.kt)("p",null,'However, in Zed, the entities that transform data are called\n"operators" instead of "commands" and unlike Unix pipelines,\nthe streams of data in a Zed query\nare typed data sequences that adhere to the\n',(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/formats/zed#the-zed-data-model-specification"},"Zed data model"),".\nMoreover, Zed sequences can be forked and joined:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"operator\n| operator\n| fork (\n  => operator | ...\n  => operator | ...\n)\n| join | ...\n")),(0,o.kt)("p",null,"Here, Zed programs can include multiple data sources and splitting operations\nwhere multiple paths run in parallel and paths can be combined (in an\nundefined order), merged (in a defined order) by one or more sort keys,\nor joined using relational-style join logic."),(0,o.kt)("p",null,"Generally speaking, a ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Directed_acyclic_graph"},"flow graph"),'\ndefines a directed acyclic graph (DAG) composed\nof data sources and operator nodes.  The Zed syntax leverages "fat arrows",\ni.e., ',(0,o.kt)("inlineCode",{parentName:"p"},"=>"),", to indicate the start of a parallel legs of the data flow."),(0,o.kt)("p",null,"That said, the Zed language is\n",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Declarative_programming"},"declarative"),"\nand the Zed compiler optimizes the data flow computation\n","\u2014"," e.g., often implementing a Zed program differently than\nthe flow implied by the pipeline yet reaching the same result ","\u2014","\nmuch as a modern SQL engine optimizes a declarative SQL query."),(0,o.kt)("p",null,"Zed is also intended to provide a seamless transition from a simple search experience\n(e.g., typed into a search bar or as the query argument of the  ",(0,o.kt)("inlineCode",{parentName:"p"},"zq")," command-line\ntool) to more a complex analytics experience composed of complex joins and aggregations\nwhere the Zed language source text would typically be authored in a editor and\nmanaged under source-code control."),(0,o.kt)("p",null,"Like an email or Web search, a simple keyword search is just the word itself,\ne.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"example.com\n")),(0,o.kt)("p",null,'is a search for the string "example.com" and'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"example.com urgent\n")),(0,o.kt)("p",null,'is a search for values with the both strings "example.com" and "urgent" present.'),(0,o.kt)("p",null,"Unlike typical log search systems, the Zed language operators are uniform:\nyou can specify an operator including keyword search terms, Boolean predicates,\netc. using the same syntax at any point in the pipeline as\n",(0,o.kt)("a",{parentName:"p",href:"#7-search-expressions"},"described below")),(0,o.kt)("p",null,"For example,\nthe predicate ",(0,o.kt)("inlineCode",{parentName:"p"},"message_length > 100")," can simply be tacked onto the keyword search\nfrom above, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"example.com urgent message_length > 100\n")),(0,o.kt)("p",null,'finds all values containing the string "example.com" and "urgent" somewhere in them\nprovided further that the field ',(0,o.kt)("inlineCode",{parentName:"p"},"message_length")," is a numeric value greater than 100.\nA related query that performs an aggregation could be more formally\nwritten as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'search "example.com" AND "urgent"\n| where message_length > 100\n| summarize kinds:=union(type) by net:=network_of(srcip)\n')),(0,o.kt)("p",null,"which computes an aggregation table of different message types (e.g.,\nfrom a hypothetical field called ",(0,o.kt)("inlineCode",{parentName:"p"},"type"),") into a new, aggregated field\ncalled ",(0,o.kt)("inlineCode",{parentName:"p"},"kinds")," and grouped by the network of all the source IP address\nin the input\n(e.g., from a hypothetical field called ",(0,o.kt)("inlineCode",{parentName:"p"},"srcip"),") as a derived field called ",(0,o.kt)("inlineCode",{parentName:"p"},"net"),"."),(0,o.kt)("p",null,"The short-hand query from above might be typed into a search box while the\nlatter query might be composed in a query editor or in Zed source files\nmaintained in GitHub.  Both forms are valid Zed queries."),(0,o.kt)("h2",{id:"2-the-dataflow-model"},"2. The Dataflow Model"),(0,o.kt)("p",null,"In Zed, each operator takes its input from the output of its upstream operator beginning\neither with a data source or with an implied source."),(0,o.kt)("p",null,"All available operators are listed on the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/"},"reference page"),"."),(0,o.kt)("h3",{id:"21-dataflow-sources"},"2.1 Dataflow Sources"),(0,o.kt)("p",null,"In addition to the data sources specified as files on the ",(0,o.kt)("inlineCode",{parentName:"p"},"zq")," command line,\na source may also be specified with the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/from#operator"},"from operator"),"."),(0,o.kt)("p",null,"When running on the command-line, ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," may refer to a file, to an HTTP\nendpoint, or to an S3 URI.  When running in a data lake, ",(0,o.kt)("inlineCode",{parentName:"p"},"from"),' typically\nrefers to a collection of data called a "data pool" and is referenced using\nthe pool\'s name much as SQL references database tables by their name.'),(0,o.kt)("p",null,"For more detail, see the reference page of the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/from#operator"},"from operator"),",\nbut as an example, you might use the ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," form of ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," to fetch data from an\nHTTP endpoint and process it with Zed, in this case, to extract the description\nand license of a GitHub repository:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'zq -f text "get https://api.github.com/repos/brimdata/zed | yield description,license.name"\n')),(0,o.kt)("p",null,"When a Zed query is run on the command-line with ",(0,o.kt)("inlineCode",{parentName:"p"},"zq"),", the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," source is\ntypically omitted and implied instead by the command-line file arguments.\nThe input may be stdin via ",(0,o.kt)("inlineCode",{parentName:"p"},"-")," as in"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"echo '\"hello, world\"' | zq  -\n")),(0,o.kt)("p",null,'The examples throughout the language documentation use this "echo pattern"\nto standard input of ',(0,o.kt)("inlineCode",{parentName:"p"},"zq -")," to illustrate language semantics.\nNote that in these examples, the input values are expressed as Zed values serialized\nin the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/formats/zson"},"ZSON text format"),"\nand the ",(0,o.kt)("inlineCode",{parentName:"p"},"zq")," query text expressed as the first argument of the ",(0,o.kt)("inlineCode",{parentName:"p"},"zq")," command\nis expressed in the syntax of the Zed language described here."),(0,o.kt)("h3",{id:"22-dataflow-operators"},"2.2 Dataflow Operators"),(0,o.kt)("p",null,"Each operator is identified by name and performs a specific operation\non a stream of records."),(0,o.kt)("p",null,"Some operators, like\n",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/summarize#operator"},"summarize")," or\n",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/sort#operator"},"sort"),",\nread all of their input before producing output though\n",(0,o.kt)("inlineCode",{parentName:"p"},"summarize")," can produce incremental results when the group-by key is\naligned with the order of the input."),(0,o.kt)("p",null,"For large queries that process all of their input, time may pass before\nseeing any output."),(0,o.kt)("p",null,"On the other hand, most operators produce incremental output by operating\non values as they are produced.  For example, a long running query that\nproduces incremental output will stream results as they are produced, i.e.,\nrunning ",(0,o.kt)("inlineCode",{parentName:"p"},"zq")," to standard output will display results incrementally."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"search")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"where"),' operators "find" values in their input and drop\nthe ones that do not match what is being looked for.'),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/yield#operator"},"yield operator")," emits one or more output values\nfor each input value based on arbitrary ",(0,o.kt)("a",{parentName:"p",href:"#expressions"},"expressions"),",\nproviding a convenient means to derive arbitrary output values as a function\nof each input value, much like the map concept in the MapReduce framework."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/fork#operator"},"fork operator")," copies its input to parallel\nlegs of a query.  The output of these parallel paths can be combined\nin a number of ways:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"merged in sorted order using the ",(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/operators/merge#operator"},"merge operator"),","),(0,o.kt)("li",{parentName:"ul"},"joined using the ",(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/operators/join#operator"},"join operator"),", or"),(0,o.kt)("li",{parentName:"ul"},"combined in an undefined order using the implied ",(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/operators/combine#operator"},"combine operator"),".")),(0,o.kt)("p",null,"A path can also be split to multiple query legs using the\n",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/switch#operator"},"switch operator"),", in which data is routed to only one\ncorresponding leg (or dropped) based on the switch clauses."),(0,o.kt)("p",null,"Switch operators typically\ninvolve multiline Zed programs, which are easiest to edit in a file.  For example,\nsuppose this text is in a file called ",(0,o.kt)("inlineCode",{parentName:"p"},"switch.zed"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-input",metastring:"switch.zed","switch.zed":!0},'switch this (\n  case 1 => yield {val:this,message:"one"}\n  case 2 => yield {val:this,message:"two"}\n  default => yield {val:this,message:"many"}\n) | merge val\n')),(0,o.kt)("p",null,"Then, running ",(0,o.kt)("inlineCode",{parentName:"p"},"zq")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"-I switch.zed")," like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 2 3 4' | zq -z -I switch.zed -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{val:1,message:"one"}\n{val:2,message:"two"}\n{val:3,message:"many"}\n{val:4,message:"many"}\n')),(0,o.kt)("p",null,"Note that the output order of the switch legs is undefined (indeed they run\nin parallel on multiple threads).  To establish a consistent sequence order,\na ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/merge"},"merge operator"),"\nmay be applied at the output of the switch specifying a sort key upon which\nto order the upstream data.  Often such order does not matter (e.g., when the output\nof the switch hits an aggregator), in which case it is typically more performant\nto omit the merge (though the Zed system will often delete such unnecessary\noperations automatically as part optimizing queries when they are compiled)."),(0,o.kt)("p",null,"If no ",(0,o.kt)("inlineCode",{parentName:"p"},"merge")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"join")," is indicated downstream of a ",(0,o.kt)("inlineCode",{parentName:"p"},"fork")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"switch"),",\nthen the implied ",(0,o.kt)("inlineCode",{parentName:"p"},"combine")," operator is presumed.  In this case, values are\nforwarded from the switch to the downstream operator in an undefined order."),(0,o.kt)("h3",{id:"23-the-special-value-this"},"2.3 The Special Value ",(0,o.kt)("inlineCode",{parentName:"h3"},"this")),(0,o.kt)("p",null,"In Zed, there are no looping constructs and variables are limited to binding\nvalues between ",(0,o.kt)("a",{parentName:"p",href:"#81-lateral-scope"},"lateral scopes")," as described below.\nInstead, the input sequence\nto an operator is produced continuously and any output values are derived\nfrom input values."),(0,o.kt)("p",null,"In contrast to SQL, where a query may refer to input tables by name,\nthere are no explicit tables and a Zed operator instead refers\nto its input values using the special identifier ",(0,o.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,o.kt)("p",null,"For example, sorting the following input"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'"foo" "bar" "BAZ"\' | zq -z sort -\n')),(0,o.kt)("p",null,"produces this case-sensitive output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'"BAZ"\n"bar"\n"foo"\n')),(0,o.kt)("p",null,"But we can make the sort case-insensitive by applying a function to the\ninputs values with the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"lower(this)"),", which converts\neach value to lower-case for use in in the sort without actually modifying\nthe input value, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'echo \'"foo" "bar" "BAZ"\' | zq -z \'sort lower(this)\' -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'"bar"\n"BAZ"\n"foo"\n')),(0,o.kt)("h3",{id:"24-implied-field-references"},"2.4 Implied Field References"),(0,o.kt)("p",null,'A common use case for Zed is to process sequences of record-oriented data\n(e.g., arising from formats like JSON or Avro) in the form of events\nor structured logs.  In this case, the input values to the operators\nare Zed "records" and the fields of a record are referenced with the dot operator.'),(0,o.kt)("p",null,"For example, if the input above were a sequence of records instead of strings\nand perhaps contained a second field, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{s:"foo",x:1}\n{s:"bar",x:2}\n{s:"BAZ",x:3}\n')),(0,o.kt)("p",null,"Then we could refer to the field ",(0,o.kt)("inlineCode",{parentName:"p"},"s")," using ",(0,o.kt)("inlineCode",{parentName:"p"},"this.s")," and sort the records\nas above with ",(0,o.kt)("inlineCode",{parentName:"p"},"sort this.s"),", which would give"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{s:"BAZ",x:3}\n{s:"bar",x:2}\n{s:"foo",x:1}\n')),(0,o.kt)("p",null,"This pattern is so common that field references to ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," may be shortened\nby simply referring to the field by name wherever a Zed expression is expected,\ne.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"sort s\n")),(0,o.kt)("p",null,"is shorthand for ",(0,o.kt)("inlineCode",{parentName:"p"},"sort this.s")),(0,o.kt)("h3",{id:"25-field-assignments"},"2.5 Field Assignments"),(0,o.kt)("p",null,"A typical operation in records involves\nadding or changing the fields of a record using the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/put#operator"},"put operator"),"\nor extracting a subset of fields using the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/cut#operator"},"cut operator"),".\nAlso, when aggregating data using group-by keys, the group-by assignments\ncreate new named record fields."),(0,o.kt)("p",null,"In all of these cases, the Zed language uses the token ",(0,o.kt)("inlineCode",{parentName:"p"},":=")," to denote\nfield assignment.  For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"put x:=y+1\n")),(0,o.kt)("p",null,"or"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"summarize salary:=sum(income) by address:=lower(address)\n")),(0,o.kt)("p",null,'This style of "assignment" to a record value is distinguished from the ',(0,o.kt)("inlineCode",{parentName:"p"},"="),"\ntoken which binds a locally scoped name to a value that can be referenced\nin later expressions."),(0,o.kt)("h3",{id:"26-implied-operators"},"2.6 Implied Operators"),(0,o.kt)("p",null,"When Zed is run in an application like ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/brimdata/brim"},"Brim"),',\nqueries are often composed interactively in a "search bar" experience.\nThe language design here attempts to support both this "lean forward" pattern of usage\nalong with a "coding style" of query writing where the queries might be large\nand complex, e.g., to perform transformations in a data pipeline, where\nthe Zed queries are stored under source-code control perhaps in GitHub or\nin Brim\'s query library.'),(0,o.kt)("p",null,"To facilitate both a programming-like model as well as an ad hoc search\nexperience, Zed has a canonical, long form that can be abbreviated\nusing syntax that supports an agile, interactive query workflow.\nTo this end, Zed allows certain operator names to be optionally omitted when\nthey can be inferred from context.  For example, the expression following\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"summarize")," operator"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"summarize count() by id\n")),(0,o.kt)("p",null,"is unambiguously an aggregation and can be shortened to"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"count() by id\n")),(0,o.kt)("p",null,'Likewise, a very common lean-forward use pattern is "searching" so by default,\nexpressions are interpreted as keyword searches, e.g.,'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"search foo bar or x > 100\n")),(0,o.kt)("p",null,"is abbreviated"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"foo bar or x > 100\n")),(0,o.kt)("p",null,"Furthermore, if an operator-free expression is not valid syntax for\na search expression but is a valid ",(0,o.kt)("a",{parentName:"p",href:"#expressions"},"Zed expression"),",\nthen the abbreviation is treated as having an implied ",(0,o.kt)("inlineCode",{parentName:"p"},"yield")," operator, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"{s:lower(s)}\n")),(0,o.kt)("p",null,"is shorthand for"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"yield {s:lower(s)}\n")),(0,o.kt)("p",null,"When operator names are omitted, ",(0,o.kt)("inlineCode",{parentName:"p"},"search")," has precedence over ",(0,o.kt)("inlineCode",{parentName:"p"},"yield"),", so"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"foo\n")),(0,o.kt)("p",null,'is interpreted as a search for the string "foo" rather than a yield of\nthe implied record field named ',(0,o.kt)("inlineCode",{parentName:"p"},"foo"),"."),(0,o.kt)("p",null,"Another common query pattern involves adding or mutating fields of records\nwhere the input is presumed to be a sequence of records.\nThe ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/put#operator"},"put operator")," provides this mechanism and the ",(0,o.kt)("inlineCode",{parentName:"p"},"put"),"\nkeyword is implied by the mutator syntax ",(0,o.kt)("inlineCode",{parentName:"p"},":="),", which is used in Zed when an\ninput record field is modified, as compared to ",(0,o.kt)("inlineCode",{parentName:"p"},"=")," which is used in constant\nand variable assignments.  For example, the operation"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"put y:=2*x+1\n")),(0,o.kt)("p",null,"can be expressed simply as"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"y:=2*x+1\n")),(0,o.kt)("p",null,"When composing long-form queries that are shared via Brim or managed in GitHub,\nit is best practice to include all operator names in the Zed source text."),(0,o.kt)("p",null,"In summary, if no operator name is given, the implied operator is determined\nfrom the operator-less source text, in the order given, as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If the text can be interpreted as a search expression, then the operator is ",(0,o.kt)("inlineCode",{parentName:"li"},"search"),"."),(0,o.kt)("li",{parentName:"ul"},"If the text can be interpreted as a boolean expression, then the operator is ",(0,o.kt)("inlineCode",{parentName:"li"},"where"),"."),(0,o.kt)("li",{parentName:"ul"},"If the text can be interpreted as one or more field assignments, then the operator is ",(0,o.kt)("inlineCode",{parentName:"li"},"put"),"."),(0,o.kt)("li",{parentName:"ul"},"If the text can be interpreted as an aggregation, then the operator is ",(0,o.kt)("inlineCode",{parentName:"li"},"summarize"),"."),(0,o.kt)("li",{parentName:"ul"},"If the text can be interpreted as an expression, then the operator is ",(0,o.kt)("inlineCode",{parentName:"li"},"yield"),"."),(0,o.kt)("li",{parentName:"ul"},"Otherwise, the text causes a compile-time error.")),(0,o.kt)("p",null,"When in doubt, you can always check what the compiler is doing under the hood\nby running ",(0,o.kt)("inlineCode",{parentName:"p"},"zq")," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"-C"),' flag to print the parsed query in "canonical form", e.g.,'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"zq -C foo\nzq -C 'is(<foo>)'\nzq -C 'count()'\nzq -C '{a:x+1,b:y-1}'\nzq -C 'a:=x+1,b:=y-1'\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"search foo\nwhere is(<foo>)\nsummarize\n    count()\nyield {a:x+1,b:y-1}\nput a:=x+1,b:=y-1\n")),(0,o.kt)("h2",{id:"3-const-statements"},"3. Const Statements"),(0,o.kt)("p",null,"Constants may be defined and assigned to a symbolic name with the syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const <id> = <expr>\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"<id>")," is an identifier and ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," is a constant ",(0,o.kt)("a",{parentName:"p",href:"#6-expressions"},"expression"),"\nthat must evaluate to a constant and at compile time and not reference any\nruntime state like ",(0,o.kt)("inlineCode",{parentName:"p"},"this"),", e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{r:5}{r:10}' | zq -z \"const PI=3.14159 2*PI*r\" -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"31.4159\n62.8318\n")),(0,o.kt)("p",null,"One or more const statements may appear only at the beginning of a scope\n(i.e., the main scope at the start of a Zed program or a ",(0,o.kt)("a",{parentName:"p",href:"#81-lateral-scope"},"lateral scope"),"\ndefined by an ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/over#operator"},"over operator"),")\nand binds the identifier to the value in the scope in which it appears in addition\nto any contained scopes."),(0,o.kt)("p",null,"A const statement cannot redefine an identifier that was previously defined in the same\nscope but can override identifiers defined in ancestor scopes."),(0,o.kt)("p",null,"Const statements may appear intermixed with type statements."),(0,o.kt)("h2",{id:"4-type-statements"},"4. Type Statements"),(0,o.kt)("p",null,"Named types may be created with the syntax"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"type <id> = <type>\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"<id>")," is an identifier and ",(0,o.kt)("inlineCode",{parentName:"p"},"<type>")," or a ",(0,o.kt)("a",{parentName:"p",href:"#first-class-types"},"Zed type"),".\nThis create a new type with the given name in the Zed type system, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo 80 | zq -z 'type port=uint16 cast(this, <port>)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"80(port=uint16)\n")),(0,o.kt)("p",null,"One or more type statements may appear at the beginning of a scope\n(i.e., the main scope at the start of a Zed program or a ",(0,o.kt)("a",{parentName:"p",href:"#lateral-scope"},"lateral scope"),"\ndefined by an ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/over#operator"},"over operator"),")\nand binds the identifier to the type in the scope in which it appears in addition\nto any contained scopes."),(0,o.kt)("p",null,"A type statement cannot redefine an identifier that was previously defined in the same\nscope but can override identifiers defined in ancestor scopes."),(0,o.kt)("p",null,"Type statements may appear intermixed with const statements."),(0,o.kt)("h2",{id:"5-data-types"},"5. Data Types"),(0,o.kt)("p",null,"The Zed language includes most data types of a typical programming language\nas defined in the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/formats/zed"},"Zed data model"),"."),(0,o.kt)("p",null,"The syntax of individual literal values generally follows\nthe ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/formats/zson"},"ZSON syntax")," with the exception that\n",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/formats/zson#22-type-decorators"},"type decorators"),"\nare not included in the language.  Instead, a\n",(0,o.kt)("a",{parentName:"p",href:"#casts"},"type cast")," may be used in any expression for explicit\ntype conversion."),(0,o.kt)("p",null,"In particular, the syntax of primitive types follows the\n",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/formats/zson#23-primitive-values"},"primitive-value definitions")," in ZSON\nas well as the various ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/formats/zson#24-complex-values"},"complex value definitions"),"\nlike records, arrays, sets, and so forth.  However, complex values are not limited to\nconstant values like ZSON and can be composed from literal expressions as\n",(0,o.kt)("a",{parentName:"p",href:"#expressions"},"defined below"),"."),(0,o.kt)("h3",{id:"51-first-class-types"},"5.1 First-class Types"),(0,o.kt)("p",null,"Like the Zed data model, the Zed language has first class types:\nany Zed type may be used as a value."),(0,o.kt)("p",null,"The primitive types are listed in the\n",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/formats/zed#1-primitive-types"},"data model specification"),"\nand have the same syntax in the Zed language.  Complex types also follow\nthe ZSON syntax.  Note that the type of a type value is simply ",(0,o.kt)("inlineCode",{parentName:"p"},"type"),"."),(0,o.kt)("p",null,"As in ZSON, ",(0,o.kt)("em",{parentName:"p"},"when types are used as values"),", e.g., in a Zed expression,\nthey must be referenced within angle brackets.  That is, the integer type\n",(0,o.kt)("inlineCode",{parentName:"p"},"int64")," is expressed as a type value using the syntax ",(0,o.kt)("inlineCode",{parentName:"p"},"<int64>"),"."),(0,o.kt)("p",null,"Complex types in the Zed language follow the ZSON syntax as well.  Here are\na few examples:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"a simple record type - ",(0,o.kt)("inlineCode",{parentName:"li"},"{x:int64,y:int64}")),(0,o.kt)("li",{parentName:"ul"},"an array of integers - ",(0,o.kt)("inlineCode",{parentName:"li"},"[int64]")),(0,o.kt)("li",{parentName:"ul"},"a set of strings - ",(0,o.kt)("inlineCode",{parentName:"li"},"|[string]|")),(0,o.kt)("li",{parentName:"ul"},"a map of strings keys to integer values - ",(0,o.kt)("inlineCode",{parentName:"li"},"{[string,int64]}")),(0,o.kt)("li",{parentName:"ul"},"a union of string and integer  - ",(0,o.kt)("inlineCode",{parentName:"li"},"(string,int64)"))),(0,o.kt)("p",null,"Complex types may be composed, as in ",(0,o.kt)("inlineCode",{parentName:"p"},"[({s:string},{x:int64})]")," which is\nan array of type union of two types of records."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/functions/typeof"},"typeof function")," returns a value's type as\na value, e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"typeof(1)")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"<int64>")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"typeof(<int64>)")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"<type>"),"."),(0,o.kt)("p",null,'First-class types are quite powerful because types can\nserve as group-by keys or be used in "data shaping" logic.\nA common query for data introspection is to perform some search query\nslicing and dicing some exploratory data then counting the shapes of\neach type of data as follows:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"search ... | count() by typeof(this)\n")),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 2 \"foo\" 10.0.0.1 <string>' | zq -z 'count() by typeof(this) | sort this' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{typeof:<int64>,count:2(uint64)}\n{typeof:<string>,count:1(uint64)}\n{typeof:<ip>,count:1(uint64)}\n{typeof:<type>,count:1(uint64)}\n")),(0,o.kt)("p",null,'When running such a query over complex, semi-structured data, the results can\nbe quite illuminating and can inform the design of "data shaping" Zed queries\nto transform raw, messy data into clean data for downstream tooling.'),(0,o.kt)("p",null,"Note the somewhat subtle difference between a record value with a field ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," of\ntype ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," whose value is type ",(0,o.kt)("inlineCode",{parentName:"p"},"string")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"{t:<string>}\n")),(0,o.kt)("p",null,"and a record type used as a value"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<{t:string}>\n")),(0,o.kt)("h3",{id:"52-named-types"},"5.2 Named Types"),(0,o.kt)("p",null,"As in any modern programming language, types can be named and the type names\npersist into the data model and thus into the serialized input and output."),(0,o.kt)("p",null,"Named types may be defined in three ways:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"with a ",(0,o.kt)("a",{parentName:"li",href:"#4-type-statements"},"type statement as described above"),","),(0,o.kt)("li",{parentName:"ul"},"with a definition inside of another type, or"),(0,o.kt)("li",{parentName:"ul"},"by the input data itself.")),(0,o.kt)("p",null,"Type names that are embedded in another type have the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"name=type\n")),(0,o.kt)("p",null,"and create a binding between the indicated string ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," and the specified ",(0,o.kt)("inlineCode",{parentName:"p"},"type"),".\nFor example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"type socket {addr:ip,port:port=uint16}\n")),(0,o.kt)("p",null,"defines a named type ",(0,o.kt)("inlineCode",{parentName:"p"},"socket")," that is a record with field ",(0,o.kt)("inlineCode",{parentName:"p"},"addr")," of type ",(0,o.kt)("inlineCode",{parentName:"p"},"ip"),"\nand field ",(0,o.kt)("inlineCode",{parentName:"p"},"port"),' of type "port", where type "port" is a named type for type ',(0,o.kt)("inlineCode",{parentName:"p"},"uint16")," ."),(0,o.kt)("p",null,"Named types may also be defined by the input data itself, as Zed data is\ncomprehensively self describing.\nWhen named types are defined in the input data, there is no need to declare their\ntype in a query.\nIn this case, a Zed expression may refer to the type by name that simply\nappears to the runtime as a side effect of operating upon the data.  If the type\nname referred to this way does not exist, then the type value reference\nresults in ",(0,o.kt)("inlineCode",{parentName:"p"},'error("missing")'),".  For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1(=foo) 2(=bar) 3(=foo)' | zq -z 'typeof(this)==<foo>' -\n")),(0,o.kt)("p",null,"results in"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"1(=foo)\n3(=foo)\n")),(0,o.kt)("p",null,"and"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1(=foo)' | zq -z 'yield <foo>' -\n")),(0,o.kt)("p",null,"results in"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"<foo=int64>\n")),(0,o.kt)("p",null,"but"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"zq -z 'yield <foo>'\n")),(0,o.kt)("p",null,"gives"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'error("missing")\n')),(0,o.kt)("p",null,"Each instance of a named type definition overrides any earlier definition.\nIn this way, types are local in scope."),(0,o.kt)("p",null,"Each value that references a named type retains its local definition of the\nnamed type retaining the proper type binding while accommodating changes in a\nparticular named type.  For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1(=foo) 2(=bar) \"hello\"(=foo) 3(=foo)' | zq -z 'count() by typeof(this) | sort this' -\n")),(0,o.kt)("p",null,"results in"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{typeof:<bar=int64>,count:1(uint64)}\n{typeof:<foo=int64>,count:2(uint64)}\n{typeof:<foo=string>,count:1(uint64)}\n")),(0,o.kt)("p",null,'Here, the two versions of type "foo" are retained in the group-by results.'),(0,o.kt)("p",null,"In general, it is bad practice to define multiple versions a single named type\nthough the Zed system and Zed data model accommodate such dynamic bindings.\nManaging and enforcing the relationship between type names and their type definitions\non a global basis (e.g., across many different data pools in a Zed lake) is outside\nthe scope of the Zed data model and language.  That said, Zed provides flexible\nbuilding blocks so systems can define their own schema versioning and schema\nmanagement policies on top of these Zed primitives."),(0,o.kt)("p",null,"Zed's super-structured data model is a superset of relational tables and\nthe Zed language's type system can easily make this connection.\nAs an example, consider this type definition for \"employee\":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"type employee {id:int64,first:string,last:string,job:string,salary:float64}\n")),(0,o.kt)("p",null,"In SQL, you might find the top five salaries by last name with"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"SELECT last,salary\nFROM employee\nORDER BY salary\nLIMIT 5\n")),(0,o.kt)("p",null,"In Zed, you would say"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"from anywhere | typeof(this)==<employee> | cut last,salary | sort salary | head 5\n")),(0,o.kt)("p",null,"and since type comparisons are so useful and common, the function ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/functions/is"},"is"),"\ncan be used to perform the type match:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"from anywhere | is(<employee>) | cut last,salary | sort salary | head 5\n")),(0,o.kt)("p",null,'The power of Zed is that you can interpret data on the fly as belonging to\na certain schemas, in this case "employee", and those records can be intermixed\nwith other relevant data.  There is no need to create a table called "employee"\nand put the data into the table before that data can be queried as an "employee".\nAnd if the schema or type name for "employee" changes, queries still continue\nto work.'),(0,o.kt)("h3",{id:"53-first-class-errors"},"5.3 First-class Errors"),(0,o.kt)("p",null,"As with types, errors in Zed are first-class: any value can be transformed\ninto an error by wrapping it in the Zed ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/formats/zed#27-error"},"error type"),"."),(0,o.kt)("p",null,"In general, expressions and functions that result in errors simply return\na value of type error as a result.  This encourages a powerful flow-style\nof error handling where errors simply propagate from one operation to the\nnext and land in the output alongside non-error values to provide a very helpful\ncontext and rich information for tracking down the source of errors.  There is\nno need to check for error conditions everywhere or look through auxiliary\nlogs to find out what happened."),(0,o.kt)("p",null,"For example,\ninput values can be transformed to errors as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '0 \"foo\" 10.0.0.1' | zq -z 'error(this)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'error(0)\nerror("foo")\nerror(10.0.0.1)\n')),(0,o.kt)("p",null,"More practically, errors from the runtime show up as error values.\nFor example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo 0 | zq -z '1/this' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'error("divide by zero")\n')),(0,o.kt)("p",null,"And since errors are first-class and just values, they have a type.\nIn particular, they are a complex type where the error value's type is the\ncomplex type error containing the type of the value.  For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo 0 | zq -z 'typeof(1/this)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"<error(string)>\n")),(0,o.kt)("p",null,"First-class errors are particularly useful for creating structured errors.\nWhen a Zed query encounters a problematic condition,\ninstead of silently dropping the problematic error\nand logging an error obscurely into some hard-to-find system log as so many\nETL pipelines do, the Zed logic can\npreferably wrap the offending value as an error and propagate it to its output."),(0,o.kt)("p",null,"For example, suppose a bad value shows up:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{kind:"bad", stuff:{foo:1,bar:2}}\n')),(0,o.kt)("p",null,"A Zed shaper could catch the bad value (e.g., as a default case in a\nswitch topology) and propagate it as an error using the Zed expression:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'yield error({message:"unrecognized input",input:this})\n')),(0,o.kt)("p",null,"then such errors could be detected and searched for downstream with the\n",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/functions/is_error"},"is_error function"),".\nFor example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"is_error(this)\n")),(0,o.kt)("p",null,"on the wrapped error from above produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'error({message:"unrecognized input",input:{kind:"bad", stuff:{foo:1,bar:2}}})\n')),(0,o.kt)("p",null,"There is no need to create special tables in a complex warehouse-style ETL\nto land such errors as they can simply land next to the output values themselves."),(0,o.kt)("p",null,'And when transformations cascade one into the next as different stages of\nan ETL pipeline, errors can be wrapped one by one forming a "stack trace"\nor lineage of where the error started and what stages it traversed before\nlanding at the final output stage.'),(0,o.kt)("p",null,"Errors will unfortunately and inevitably occur even in production,\nbut having a first-class data type to manage them all while allowing them to\npeacefully coexist with valid production data is a novel and\nuseful approach that Zed enables."),(0,o.kt)("h4",{id:"531-missing-and-quiet"},"5.3.1 Missing and Quiet"),(0,o.kt)("p",null,"Zed's heterogeneous data model allows for queries\nthat operate over different types of data whose structure and type\nmay not be known ahead of time, e.g., different\ntypes of records with different field names and varying structure.\nThus, a reference to a field, e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"this.x")," may be valid for some values\nthat include a field called ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," but not valid for those that do not."),(0,o.kt)("p",null,"What is the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," when the field ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," does not exist?"),(0,o.kt)("p",null,"A similar question faced SQL when it was adapted in various different forms\nto operate on semi-structured data like JSON or XML.  SQL already had the ",(0,o.kt)("inlineCode",{parentName:"p"},"NULL")," value\nso perhaps a reference to a missing value could simply be ",(0,o.kt)("inlineCode",{parentName:"p"},"NULL"),"."),(0,o.kt)("p",null,"But JSON also has ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),", so a reference to ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," in the JSON value"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{"x":null}\n')),(0,o.kt)("p",null,"and a reference to ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," in the JSON value"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"{}\n")),(0,o.kt)("p",null,"would have the same value of ",(0,o.kt)("inlineCode",{parentName:"p"},"NULL"),".  Furthermore, an expression like ",(0,o.kt)("inlineCode",{parentName:"p"},"x==NULL"),"\ncould not differentiate between these two cases."),(0,o.kt)("p",null,"To solve this problem, the ",(0,o.kt)("inlineCode",{parentName:"p"},"MISSING")," value was proposed to represent the value that\nresults from accessing a field that is not present.  Thus, ",(0,o.kt)("inlineCode",{parentName:"p"},"x==NULL")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"x==MISSING")," could disambiguate the two cases above."),(0,o.kt)("p",null,"Zed, instead, recognizes that the SQL value is ",(0,o.kt)("inlineCode",{parentName:"p"},"MISSING")," is a paradox:\nI'm here but I'm not.  "),(0,o.kt)("p",null,"In reality, a MISSING value is not a value.  It's an error condition\nthat resulted from trying to reference something that didn't exist."),(0,o.kt)("p",null,"So why should we pretend that this is a bona fide value?  SQL adopted this\napproach because it lacks first-class errors."),(0,o.kt)("p",null,"But Zed has first-class errors so\na reference to something that does not exist is an error of type\n",(0,o.kt)("inlineCode",{parentName:"p"},"error<string>")," whose value is ",(0,o.kt)("inlineCode",{parentName:"p"},'error("missing")'),".  For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo \"{x:1} {y:2}\" | zq -z 'yield x' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'1\nerror("missing")\n')),(0,o.kt)("p",null,"Sometimes you want missing errors to show up and sometimes you don't.\nThe ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/functions/quiet"},"quiet function"),' transforms missing errors into\n"quiet errors".  A quiet error is the value ',(0,o.kt)("inlineCode",{parentName:"p"},'error("quiet")')," and is ignored\nby most operators, in particular yield.  For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo "{x:1} {y:2}" | zq -z "yield quiet(x)" -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"1\n")),(0,o.kt)("h2",{id:"6-expressions"},"6. Expressions"),(0,o.kt)("p",null,"Zed expressions follow the typical patterns in programming languages.\nExpressions are typically used within data flow operators\nto perform computation on input values and are typically evaluated once per each\ninput value ",(0,o.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,o.kt)("p",null,"For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"yield"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"where"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"cut"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"put"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"sort")," and so forth all take\nvarious expressions as part of their operation."),(0,o.kt)("h3",{id:"61-arithmetic"},"6.1 Arithmetic"),(0,o.kt)("p",null,"Arithmetic operations (",(0,o.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"/"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"%"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"-"),") follow customary syntax\nand semantics and are left-associative with multiplication and division having\nprecedence over addition and subtraction.  ",(0,o.kt)("inlineCode",{parentName:"p"},"%")," is the modulo operator."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -z \'yield 2*3+1, 11%5, 1/0, "foo"+"bar"\'\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'7\n1\nerror("divide by zero")\n"foobar"\n')),(0,o.kt)("h3",{id:"62-comparisons"},"6.2 Comparisons"),(0,o.kt)("p",null,"Comparison operations (",(0,o.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"=="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"!="),", ",(0,o.kt)("inlineCode",{parentName:"p"},">"),", ",(0,o.kt)("inlineCode",{parentName:"p"},">="),") follow customary syntax\nand semantics and result in a truth value of type ",(0,o.kt)("inlineCode",{parentName:"p"},"bool")," or an error.\nA comparison expression is any valid Zed expression compared to any other\nvalid Zed expression using a comparison operator."),(0,o.kt)("p",null,"When the operands are coercible to like types, the result is the truth value\nof the comparison.  Otherwise, the result is ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,o.kt)("p",null,"If either operand to a comparison\nis ",(0,o.kt)("inlineCode",{parentName:"p"},'error("missing")'),", then the result is ",(0,o.kt)("inlineCode",{parentName:"p"},'error("missing")'),"."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -z \'yield 1 > 2, 1 < 2, "b" > "a", 1 > "a", 1 > x\'\n\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'false\ntrue\ntrue\nfalse\nerror("missing")\n')),(0,o.kt)("h3",{id:"63-containment"},"6.3 Containment"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"in")," operator has the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<item-expr> in <container-expr>\n")),(0,o.kt)("p",null,"and is true if the ",(0,o.kt)("inlineCode",{parentName:"p"},"<item-expr>")," expression results in a value that\nappears somewhere in the ",(0,o.kt)("inlineCode",{parentName:"p"},"<container-expr>")," as an exact match of the item.\nThe right-hand side value can be any Zed value and complex values are\nrecursively traversed to determine if the item is present anywhere within them."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{a:[1,2]}{b:{c:3}}{d:{e:1}}' | zq -z '1 in this' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{a:[1,2]}\n{d:{e:1}}\n")),(0,o.kt)("p",null,"You can also use this operator with a static array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{accounts:[{id:1},{id:2},{id:3}]}' | zq -z 'over accounts | where id in [1,2]' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{id:1}\n{id:2}\n")),(0,o.kt)("h3",{id:"64-logic"},"6.4 Logic"),(0,o.kt)("p",null,"The keywords ",(0,o.kt)("inlineCode",{parentName:"p"},"and"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"or"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"not")," perform logic on operands of type ",(0,o.kt)("inlineCode",{parentName:"p"},"bool"),".\nThe binary operators ",(0,o.kt)("inlineCode",{parentName:"p"},"and")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," operate on Boolean values and result in\nan error value if either operand is not a Boolean.  Likewise, ",(0,o.kt)("inlineCode",{parentName:"p"},"not")," operates\non its unary operand and results in an error if its operand is not type ",(0,o.kt)("inlineCode",{parentName:"p"},"bool"),'.\nUnlike many other languages, non-Boolean values are not automatically converted to\nBoolean type using "truthiness" heuristics.'),(0,o.kt)("h3",{id:"65-field-dereference"},"6.5 Field Dereference"),(0,o.kt)("p",null,"Records fields are dereferenced with the dot operator ",(0,o.kt)("inlineCode",{parentName:"p"},".")," as is customary\nin other languages and have the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<value> . <id>\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"<id>")," is an identifier representing the field name referenced.\nIf a field name is not representable as an identifier, then ",(0,o.kt)("a",{parentName:"p",href:"#indexing"},"indexing"),"\nmay be used with a quoted string to represent any valid field name.\nSuch field names can be accessed using ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," and an array-style\nreference, e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},'this["field with spaces"]'),"."),(0,o.kt)("p",null,"If the dot operator is applied to a value that is not a record\nor if the record does not have the given field, then the result is\n",(0,o.kt)("inlineCode",{parentName:"p"},'error("missing")'),"."),(0,o.kt)("h3",{id:"66-indexing"},"6.6 Indexing"),(0,o.kt)("p",null,"The index operation can be applied to various data types and has the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<value> [ <index> ]\n")),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is a record, then the ",(0,o.kt)("inlineCode",{parentName:"p"},"<index>")," operand\nmust be coercible to a string and the result of the record's field\nof that name."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is an array, then the ",(0,o.kt)("inlineCode",{parentName:"p"},"<index>")," operand\nmust be coercible to an integer and the result is the\nvalue in the array of that index."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is a set, then the ",(0,o.kt)("inlineCode",{parentName:"p"},"<index>")," operand\nmust be coercible to an integer and the result is the\nvalue in the set of that index ordered by total order of Zed values."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is a map, then the ",(0,o.kt)("inlineCode",{parentName:"p"},"<index>")," operand\nis presumed to be a key and the corresponding value for that key is\nthe result of the operation.  If no such key exists in the map, then\n",(0,o.kt)("inlineCode",{parentName:"p"},'error("missing")')," results."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is a string, then the ",(0,o.kt)("inlineCode",{parentName:"p"},"<index>")," operand\nmust be coercible to an integer and the result is an integer representing\nthe unicode code point at that offset in the string."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is type bytes, then the ",(0,o.kt)("inlineCode",{parentName:"p"},"<index>")," operand\nmust be coercible to an integer and the result is an unsigned 8-bit integer\nrepresenting the byte value at that offset in the bytes sequence."),(0,o.kt)("h3",{id:"67-slices"},"6.7 Slices"),(0,o.kt)("p",null,"The slice operation can be applied to various data types and has the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<value> [ <from> : <to> ]\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"<from>")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"<to>")," terms must be expressions that are coercible\nto integer and represent a range of index values to form a subset of elements\nfrom the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," term provided.  The range begins at the ",(0,o.kt)("inlineCode",{parentName:"p"},"<from>")," position\nand ends one before the ",(0,o.kt)("inlineCode",{parentName:"p"},"<to>")," position.  A negative\nvalue of ",(0,o.kt)("inlineCode",{parentName:"p"},"<from>")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"<to>")," represents a position relative to the\nend of the value being sliced."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is an array, then the result is an array of\nelements comprising the indicated range."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is a set, then the result is a set of\nelements comprising the indicated range ordered by total order of Zed values."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is a string, then the result is a substring\nconsisting of unicode code points comprising the given range."),(0,o.kt)("p",null,"If the ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," expression is type bytes, then the result is a bytes sequence\nconsisting of bytes comprising the given range."),(0,o.kt)("h3",{id:"68-conditional"},"6.8 Conditional"),(0,o.kt)("p",null,"A conditional expression has the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<boolean> ? <expr> : <expr>`\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"<boolean>")," expression is evaluated and must have a result of type ",(0,o.kt)("inlineCode",{parentName:"p"},"bool"),".\nIf not, an error results."),(0,o.kt)("p",null,"If the result is true, then the first ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," expression is evaluated and becomes\nthe result.  Otherwise, the second ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," expression is evaluated."),(0,o.kt)("p",null,"Note that if the expression has side effects,\nas with ",(0,o.kt)("a",{parentName:"p",href:"#aggregation-calls"},"aggregation calls"),", only the selected expression\nwill be evaluated."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{s:"foo",v:1}{s:"bar",v:2}\' | zq -z \'yield (s=="foo") ? v : -v\' -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"1\n-2\n")),(0,o.kt)("h3",{id:"69-function-calls"},"6.9 Function Calls"),(0,o.kt)("p",null,"Functions perform stateless transformations of their input value to their\nreturn value and utilize call-by value semantics with positional and unnamed\narguments.  Some functions take a variable number of arguments."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The only available functions are built-in but user-defined functions and\nlibrary package management will be added to the Zed language soon.")),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -z \'yield pow(2,3), lower("ABC")+upper("def"), typeof(1)\'\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'8.\n"abcDEF"\n<int64>\n')),(0,o.kt)("h3",{id:"610-aggregate-function-calls"},"6.10 Aggregate Function Calls"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/aggregates/"},"Aggregate functions")," may be called within an expression.\nUnlike the aggregation context provided by a summarizing group-by, such calls\nin expression context yield an output value for each input value."),(0,o.kt)("p",null,"Note that because aggregate functions carry state which is typically\ndependent on the order of input values, their use can prevent the runtime\noptimizer from parallelizing a query."),(0,o.kt)("p",null,"That said, aggregate function calls can be quite useful in a number of contexts.\nFor example, a unique ID can be assigned to the input quite easily:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'"foo" "bar" "baz"\' | zq -z \'yield {id:count(),value:this}\' -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{id:1(uint64),value:"foo"}\n{id:2(uint64),value:"bar"}\n{id:3(uint64),value:"baz"}\n')),(0,o.kt)("p",null,"In contrast, calling aggregate functions within ",(0,o.kt)("inlineCode",{parentName:"p"},"summarize")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'"foo" "bar" "baz"\' | zq -z \'summarize count(),union(this)\' -\n')),(0,o.kt)("p",null,"produces just one output value"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{count:3(uint64),union:|["bar","baz","foo"]|}\n')),(0,o.kt)("h3",{id:"611-literals"},"6.11 Literals"),(0,o.kt)("p",null,"Any of the ",(0,o.kt)("a",{parentName:"p",href:"#data-types"},"data types listed above")," may be used in expressions\nas long as it is compatible with the semantics of the expression."),(0,o.kt)("p",null,"String literals are enclosed in either single quotes or double quotes and\nmust conform to UTF-8 encoding and follow the JavaScript escaping\nconventions and unicode escape syntax.  Also, if the sequence ",(0,o.kt)("inlineCode",{parentName:"p"},"${")," appears\nin a string the ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," character must be escaped, i.e., ",(0,o.kt)("inlineCode",{parentName:"p"},"\\$"),"."),(0,o.kt)("h4",{id:"6111-string-interpolation"},"6.11.1 String Interpolation"),(0,o.kt)("p",null,"Strings may include interpolation expressions, which has the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"${ <expr> }\n")),(0,o.kt)("p",null,"In this case, the characters starting with ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," and ending at ",(0,o.kt)("inlineCode",{parentName:"p"},"}")," are substituted\nwith the result of evaluating the expression ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>"),".  If this result is not\na string, it is implicitly cast to a string."),(0,o.kt)("p",null,"If any template expression results in an error, then the value of the template\nliteral is the first error encountered in left-to-right order."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"TBD: we could improve an error result here by creating a structured error\ncontaining the string template text along with a list of values/errors of\nthe expressions.")),(0,o.kt)("p",null,"String interpolation may be nested, where ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," contains additional strings\nwith interpolated expressions."),(0,o.kt)("h4",{id:"6112-record-expressions"},"6.11.2 Record Expressions"),(0,o.kt)("p",null,"Record literals have the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"{ <spec>, <spec>, ... }\n")),(0,o.kt)("p",null,"where a ",(0,o.kt)("inlineCode",{parentName:"p"},"<spec>")," has one of three forms:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<field> : <expr>\n<ref>\n...<expr>\n")),(0,o.kt)("p",null,"The first form is a customary colon-separated field and value similar to JavaScript,\nwhere ",(0,o.kt)("inlineCode",{parentName:"p"},"<field>")," may be an identifier or quoted string.\nThe second form is an implied field reference ",(0,o.kt)("inlineCode",{parentName:"p"},"<ref>"),", which is shorthand\nfor ",(0,o.kt)("inlineCode",{parentName:"p"},"<ref>:<ref>"),".  The third form is the ",(0,o.kt)("inlineCode",{parentName:"p"},"...")," spread operator which expects\na record value as the result of ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," and inserts all of the fields from\nthe resulting record.\nIf a spread expression results in a non-record type (e.g., errors), then that\npart of record is simply elided."),(0,o.kt)("p",null,"The fields of a record expression are evaluated left to right and when\nfield names collide the rightmost instance of the name determines that\nfield's value."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{x:1,y:2,r:{a:1,b:2}}' | zq -z 'yield {a:0},{x}, {...r}, {a:0,...r,b:3}' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{a:0}\n{x:1}\n{a:1,b:2}\n{a:1,b:3}\n")),(0,o.kt)("h4",{id:"6113-array-expressions"},"6.11.3 Array Expressions"),(0,o.kt)("p",null,"Array literals have the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"[ <expr>, <expr>, ... ]\n")),(0,o.kt)("p",null,"When the expressions result in values of non-uniform type, then the implied\ntype of the array is an array of type union of the types that appear."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -z \'yield [1,2,3],["hello","world"]\'\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'[1,2,3]\n["hello","world"]\n')),(0,o.kt)("h4",{id:"6114-set-expressions"},"6.11.4 Set Expressions"),(0,o.kt)("p",null,"Set literals have the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"|[ <expr>, <expr>, ... ]|\n")),(0,o.kt)("p",null,"When the expressions result in values of non-uniform type, then the implied\ntype of the set is a set of type union of the types that appear."),(0,o.kt)("p",null,'Set values are always organized in their "natural order" independent of the order\nthey appear in the set literal.'),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -z \'yield |[3,1,2]|,|["hello","world","hello"]|\'\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'|[1,2,3]|\n|["hello","world"]|\n')),(0,o.kt)("h4",{id:"6115-map-expressions"},"6.11.5 Map Expressions"),(0,o.kt)("p",null,"Map literals have the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"|{ <expr>:<expr>, <expr>:<expr>, ... }|\n")),(0,o.kt)("p",null,"where the first expression of each colon-separated entry is the key value\nand the second expression is the value.\nWhen the key and/or value expressions results in values of non-uniform type,\nthen the implied type of the map has a key type and/or value type that is\na union of the types that appear in each respective category."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -z \'yield |{"foo":1,"bar"+"baz":2+3}|\'\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'|{"foo":1,"barbaz":5}|\n')),(0,o.kt)("h4",{id:"6116-union-values"},"6.11.6 Union Values"),(0,o.kt)("p",null,"A union value can be created with a cast.  For example, a union of types ",(0,o.kt)("inlineCode",{parentName:"p"},"int64"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," is expressed as ",(0,o.kt)("inlineCode",{parentName:"p"},"(int64,string)")," and any value that has a type\nthat appears in the union type may be cast to that union type.\nSince 1 is an ",(0,o.kt)("inlineCode",{parentName:"p"},"int64"),' and "foo" is a ',(0,o.kt)("inlineCode",{parentName:"p"},"string"),", they both can be\nvalues of type ",(0,o.kt)("inlineCode",{parentName:"p"},"(int64,string)"),", e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 \"foo\"' | zq -z 'yield cast(this,<(int64,string)>)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'1((int64,string))\n"foo"((int64,string))\n')),(0,o.kt)("p",null,"The value underlying a union-tagged value is accessed with the\n",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/functions/under"},"under function"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1((int64,string))' | zq -z 'yield under(this)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"1\n")),(0,o.kt)("p",null,"Union values are powerful because they provide a mechanism to precisely\ndescribe the type of any nested, semi-structured value composed of elements\nof different types.  For example, the type of the value ",(0,o.kt)("inlineCode",{parentName:"p"},'[1,"foo"]'),' in Javascript\nis simply a generic Javascript "object".  But in Zed, the type of this\nvalue is an array of union of string and integer, e.g.,'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '[1,\"foo\"]' | zq -z 'typeof(this)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"<[(int64,string)]>\n")),(0,o.kt)("h3",{id:"612-constants"},"6.12 Constants"),(0,o.kt)("p",null,"Constants may be declared and bound to an identifier with a ",(0,o.kt)("inlineCode",{parentName:"p"},"const")," statement,\nwhich has the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const <id> = <expr>\n")),(0,o.kt)("p",null,"This statement evaluates the expressions ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," before any input is processed\nto determine the constant value assigned to the identifier ",(0,o.kt)("inlineCode",{parentName:"p"},"<id>"),".\nThis expression may not refer to ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," or any implied fields of ",(0,o.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,o.kt)("p",null,"Constants must appear at the beginning\nof a query or the beginning of a ",(0,o.kt)("a",{parentName:"p",href:"#scopes"},"parenthesized scope"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{diameter:1}{diameter:5}' | zq -z 'const PI = 3.14159 circumference:=2*PI*diameter' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{diameter:1,circumference:6.28318}\n{diameter:5,circumference:31.4159}\n")),(0,o.kt)("h3",{id:"613-type-definitions"},"6.13 Type Definitions"),(0,o.kt)("p",null,"Named types may be declared and bound to an identifier with a ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," statement,\nwhich has the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"type <name> = <type>\n")),(0,o.kt)("p",null,"This statement evaluates the type ",(0,o.kt)("inlineCode",{parentName:"p"},"<type>")," before any input is processed\nto compute a type value assigned to the identifier ",(0,o.kt)("inlineCode",{parentName:"p"},"<id>"),"."),(0,o.kt)("p",null,"In addition, a type statement creates a binding for the named type in\nthe runtime's type system, which may be overridden by any input that\nredefines the named type."),(0,o.kt)("p",null,"When referred to by the defined identifier, the use of this type is not\noverridden by the input data; however, type values that refer to the named\ntype may be redefined."),(0,o.kt)("p",null,"Type definitions must appear at the beginning\nof a query or the beginning of a ",(0,o.kt)("a",{parentName:"p",href:"#scopes"},"parenthesized scope"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{s:1}{s:10.0.0.1}' | zq -z 'type foo = {s:string} cast(this, foo)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"1"}(=foo)\n{s:"10.0.0.1"}(=foo)\n')),(0,o.kt)("h3",{id:"614-casts"},"6.14 Casts"),(0,o.kt)("p",null,"Type conversion is performed with casts and the built-in function ",(0,o.kt)("inlineCode",{parentName:"p"},"cast()"),"."),(0,o.kt)("p",null,"Casts for primitive types have a function-style syntax of the form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<type> ( <expr> )\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"<type>")," is a Zed type and ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," is any Zed expression.\nIn the case of primitive types, the type-value angle brackets\nmay be omitted, e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"<string>(1)")," is equivalent to ",(0,o.kt)("inlineCode",{parentName:"p"},"string(1)"),".\nIf the result of ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," cannot be converted\nto the indicated type, then the cast's result is an error value."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '1 200 \"123\" \"200\"' | zq -z 'yield int8(this)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'1(int8)\nerror("cannot cast 200 to type int8")\n123(int8)\nerror("cannot cast \\"200\\" to type int8")\n')),(0,o.kt)("p",null,"Casting attempts to be fairly liberal in conversions.  For example, values\nof type ",(0,o.kt)("inlineCode",{parentName:"p"},"time")," can be created from a diverse set of data/time input strings\nbased on the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/araddon/dateparse"},"Go Date Parser library"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '\"May 8, 2009 5:57:51 PM\" \"oct 7, 1970\"' | zq -z 'yield time(this)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"2009-05-08T17:57:51Z\n1970-10-07T00:00:00Z\n")),(0,o.kt)("p",null,"Casts of complex or named types may be performed using type values\neither in functional form or with ",(0,o.kt)("inlineCode",{parentName:"p"},"cast"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<type-value> ( <expr> )\ncast(<expr>, <type-value>)\n")),(0,o.kt)("p",null,"For example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '80 8080' | zq -z 'type port = uint16 yield <port>(this)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"80(port=uint16)\n8080(port=uint16)\n")),(0,o.kt)("p",null,"Casts may be used with complex types as well.  As long as the target type can\naccommodate the value, the case will be recursively applied to the components\nof a nested value.  For example,\nFor example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '[\"10.0.0.1\",\"10.0.0.2\"]' | zq -z 'cast(this,<[ip]>)' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"[10.0.0.1,10.0.0.2]\n")),(0,o.kt)("p",null,"and"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{ts:"1/1/2022",r:{x:"1",y:"2"}} {ts:"1/2/2022",r:{x:3,y:4}}\' | zq -z \'cast(this,<{ts:time,r:{x:float64,y:float64}}>)\' -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{ts:2022-01-01T00:00:00Z,r:{x:1.,y:2.}}\n{ts:2022-01-02T00:00:00Z,r:{x:3.,y:4.}}\n")),(0,o.kt)("h2",{id:"7-search-expressions"},"7. Search Expressions"),(0,o.kt)("p",null,'Search expressions provide a hybrid syntax between keyword search\nand boolean expressions.  In this way, a search is a shorthand for\na "lean forward" style activity where one is interactively exploring\ndata with ad hoc searches.  All shorthand searches have a corresponding\nlong form built from the expression syntax above in combination with the\n',(0,o.kt)("a",{parentName:"p",href:"#721-search-terms"},"search term syntax")," described below."),(0,o.kt)("h3",{id:"71-search-patterns"},"7.1 Search Patterns"),(0,o.kt)("p",null,"Several styles of string search can be performed with a search expression\n(as well as the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/functions/grep"},"grep function"),') using "patterns",\nwhere a pattern is a regular expression, glob, or simple string.'),(0,o.kt)("h4",{id:"711-regular-expressions"},"7.1.1 Regular Expressions"),(0,o.kt)("p",null,"A regular expression is specified in the familiar slash syntax where the\nexpression begins with a ",(0,o.kt)("inlineCode",{parentName:"p"},"/")," character and ends with a terminating ",(0,o.kt)("inlineCode",{parentName:"p"},"/")," character.\nThe string between the slashed (exclusive of those characters) is the\nregular expression."),(0,o.kt)("p",null,"The format of Zed regular expressions follows the syntax of the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/google/re2"},"RE2 regular expression library"),"\nand is documented in the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/google/re2/wiki/Syntax"},"RE2 Wiki"),"."),(0,o.kt)("p",null,"Regular expressions may be used freely in search expressions, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'"foo" {s:"bar"} {s:"baz"} {foo:1}\' | zq -z \'/(foo|bar)/\' -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'"foo"\n{s:"bar"}\n{foo:1}\n')),(0,o.kt)("p",null,"Regular expressions may also appear in the ",(0,o.kt)("inlineCode",{parentName:"p"},"grep")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'"foo" {s:"bar"} {s:"baz"} {foo:1}\' | zq -z \'yield grep(/ba.*/, s)\' -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"false\ntrue\ntrue\nfalse\n")),(0,o.kt)("h4",{id:"712-globs"},"7.1.2 Globs"),(0,o.kt)("p",null,'Globs provide a convenient short-hand for regular expressions and follow\nthe familiar pattern of "file globbing" supported by Unix shells.\nZed globs are a simple, special case utilize only the ',(0,o.kt)("inlineCode",{parentName:"p"},"*")," wildcard."),(0,o.kt)("p",null,"Valid glob characters include ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"z"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"Z"),",\nany valid string escape sequence\n(along with escapes for ",(0,o.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"-"),"), and the unescaped characters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"_ . : / % # @ ~\n")),(0,o.kt)("p",null,"A glob must begin with one of these characters or ",(0,o.kt)("inlineCode",{parentName:"p"},"*")," then may be\nfollowed by any of these characters, ",(0,o.kt)("inlineCode",{parentName:"p"},"*"),", or digits ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"9"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that these rules do not allow for a leading digit.")),(0,o.kt)("p",null,"For example, a prefix match is easily accomplished via ",(0,o.kt)("inlineCode",{parentName:"p"},"prefix*"),", e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'"foo" {s:"bar"} {s:"baz"} {foo:1}\' | zq -z \'b*\' -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"bar"}\n{s:"baz"}\n')),(0,o.kt)("p",null,"Likewise, a suffix match may be performed as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'"foo" {s:"bar"} {s:"baz"} {foo:1}\' | zq -z \'*z\' -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"baz"}\n')),(0,o.kt)("p",null,"and"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'"foo" {s:"bar"} {s:"baz"} {a:1}\' | zq -z \'*a*\' -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"bar"}\n{s:"baz"}\n{a:1}\n')),(0,o.kt)("p",null,"Note that a glob may look like multiplication but context disambiguates\nthese condition, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"a*b\n")),(0,o.kt)("p",null,"is a glob match for any matching string value in the input, but"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"a*b==c\n")),(0,o.kt)("p",null,"is a Boolean comparison between the product ",(0,o.kt)("inlineCode",{parentName:"p"},"a*b")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"c"),"."),(0,o.kt)("h3",{id:"72-search-logic"},"7.2 Search Logic"),(0,o.kt)("p",null,'The search patterns described above can be combined with other elements\nto a search expression comprised of "search terms" that may be combined\nusing Boolean logic.'),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that when processing ZNG data, the Zed runtime performs a multi-threaded\nBoyer-Moore scan over decompressed data buffers before parsing any data.\nThis allows large buffers of data to be efficiently discarded and skipped when\nsearching for rarely occurring values.  For a ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/lake/format"},"Zed lake"),", search indexes\nmay also be configured to further accelerate searches.\nIn a forthcoming release, Zed will also offer an approach for locating\ndelimited words within string fields, which will allow accelerated\nsearch using a full-text search index.  Currently, search indexes may be built\nfor exact value match as text segmentation is in the works.a")),(0,o.kt)("h4",{id:"721-search-terms"},"7.2.1 Search Terms"),(0,o.kt)("p",null,'A "search term" is one of the following;'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"a regular expression as described above,"),(0,o.kt)("li",{parentName:"ul"},"a glob as described above,"),(0,o.kt)("li",{parentName:"ul"},"a keyword,"),(0,o.kt)("li",{parentName:"ul"},"any literal of a primitive type, or"),(0,o.kt)("li",{parentName:"ul"},"expression predicates.")),(0,o.kt)("h5",{id:"7211-regular-expression-search-term"},"7.2.1.1 Regular Expression Search Term"),(0,o.kt)("p",null,"A regular expression ",(0,o.kt)("inlineCode",{parentName:"p"},"/re/")," is equivalent to"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"grep(/reg/, this)\n")),(0,o.kt)("p",null,"but shorter and easier to type in a search expression."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"/(foo|bar.*baz.*\\.com)/\n")),(0,o.kt)("p",null,"Searches for any string that begins with ",(0,o.kt)("inlineCode",{parentName:"p"},"foo")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"bar")," has the string\n",(0,o.kt)("inlineCode",{parentName:"p"},"baz")," in it and ends with ",(0,o.kt)("inlineCode",{parentName:"p"},".com"),"."),(0,o.kt)("h5",{id:"7212-glob-search-term"},"7.2.1.2 Glob Search Term"),(0,o.kt)("p",null,"A glob search term ",(0,o.kt)("inlineCode",{parentName:"p"},"<glob>")," is equivalent to"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"grep(/reg/, this)\n")),(0,o.kt)("p",null,"but shorter and easier to type in a search expression."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"foo*baz*.com\n")),(0,o.kt)("p",null,"Searches for any string that begins with ",(0,o.kt)("inlineCode",{parentName:"p"},"foo")," has the string\n",(0,o.kt)("inlineCode",{parentName:"p"},"baz")," in it and ends with ",(0,o.kt)("inlineCode",{parentName:"p"},".com"),"."),(0,o.kt)("h5",{id:"7213-keyword-search-term"},"7.2.1.3 Keyword Search Term"),(0,o.kt)("p",null,"Keywords and string literals are equivalent search terms so it is often\neasier to quote a string search term instead of using escapes in a keyword.\nKeywords are useful in interactive modes of use where searches can be issued\nand modified quickly without having to type matching quotes."),(0,o.kt)("p",null,"Keyword search has the look and feel of Web search or email search."),(0,o.kt)("p",null,"Valid keyword characters include ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"z"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"A")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"Z"),",\nany valid string escape sequence\n(along with escapes for ",(0,o.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"-"),"), and the unescaped characters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"_ . : / % # @ ~\n")),(0,o.kt)("p",null,"A keyword must begin with one of these characters then may be\nfollowed by any of these characters or digits ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"9"),"."),(0,o.kt)("p",null,"A keyword search is equivalent to"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"grep(<keyword>, this)\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"<keyword>")," is the quoted string-literal of the unquoted string.\nFor example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"search foo\n")),(0,o.kt)("p",null,"is equivalent to"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'where grep("foo", this)\n')),(0,o.kt)("p",null,'Note that the "search" keyword may be omitted.\nFor example, the simplest Zed program is perhaps a single keyword search, e.g.,'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"foo\n")),(0,o.kt)("p",null,'As above, this program searches the implied input for input values that\ncontain the string "foo".'),(0,o.kt)("h5",{id:"7214-string-literal-search-term"},"7.2.1.4 String Literal Search Term"),(0,o.kt)("p",null,"A string literal as a search term is simply a search for that string and is\nequivalent to"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"grep(<string>, this)\n")),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'search "foo"\n')),(0,o.kt)("p",null,"is equivalent to"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'where grep("foo", this)\n')),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that this equivalency between keyword search terms and grep semantics\nwill change in the near future when we add support for full-text search.\nIn this case, grep will still support substring match but keyword search\nwill match segmented words from string fields so that they can be efficiently\nqueried in search indexes.")),(0,o.kt)("h5",{id:"7215-non-string-literal-search-term"},"7.2.1.5 Non-String Literal Search Term"),(0,o.kt)("p",null,"Search terms representing non-string Zed values search for both an exact\nmatch for the given value as well as a string search for the term exactly\nas it appears as typed.  Such values include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"integers,"),(0,o.kt)("li",{parentName:"ul"},"floating point numbers,"),(0,o.kt)("li",{parentName:"ul"},"time values,"),(0,o.kt)("li",{parentName:"ul"},"durations,"),(0,o.kt)("li",{parentName:"ul"},"IPs,"),(0,o.kt)("li",{parentName:"ul"},"networks,"),(0,o.kt)("li",{parentName:"ul"},"bytes values, and"),(0,o.kt)("li",{parentName:"ul"},"type values.")),(0,o.kt)("p",null,"A search for a Zed value ",(0,o.kt)("inlineCode",{parentName:"p"},"<value>")," represented as the string ",(0,o.kt)("inlineCode",{parentName:"p"},"<string>")," is\nequivalent to"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<value> in this or grep(<string>, this)\n")),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"search 123 and 10.0.0.1\n")),(0,o.kt)("p",null,"which can be abbreviated"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"123 10.0.0.1\n")),(0,o.kt)("p",null,"is equivalent to"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'where (123 in this or grep("123", this)) and (10.0.0.1 in this or grep("10.0.0.1", this))\n')),(0,o.kt)("p",null,'Complex values are not supported as search terms but may be queried with\nthe "in" operator, e.g.,'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{s:"foo"} in this\n')),(0,o.kt)("h5",{id:"7216-predicate-search-term"},"7.2.1.6 Predicate Search Term"),(0,o.kt)("p",null,"Any Boolean-valued ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/functions/"},"function")," like ",(0,o.kt)("inlineCode",{parentName:"p"},"is()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"has()"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"grep()")," etc. and any ",(0,o.kt)("a",{parentName:"p",href:"#comparisons"},"comparison expression"),"\nmay be used as a search term and mixed into a search expression."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"is(<foo>) has(bar) baz x==y+z\n")),(0,o.kt)("p",null,"is a valid search expression but"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"/foo.*/ x+1\n")),(0,o.kt)("p",null,"is not."),(0,o.kt)("h4",{id:"73-boolean-logic"},"7.3 Boolean Logic"),(0,o.kt)("p",null,"Search terms may be combined into boolean expressions using logical operators\n",(0,o.kt)("inlineCode",{parentName:"p"},"and"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"or")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"not"),".  ",(0,o.kt)("inlineCode",{parentName:"p"},"and")," may be elided; i.e., concatenation of search terms\nis a logical ",(0,o.kt)("inlineCode",{parentName:"p"},"and"),".  ",(0,o.kt)("inlineCode",{parentName:"p"},"not")," has highest precedence and ",(0,o.kt)("inlineCode",{parentName:"p"},"and")," has precedence over\n",(0,o.kt)("inlineCode",{parentName:"p"},"or"),".  Parentheses may be used to override natural precedence."),(0,o.kt)("p",null,"Note that the concatenation form of ",(0,o.kt)("inlineCode",{parentName:"p"},"and")," is not valid in standard expressions and\nis available only in search expressions.\nConcatenation is convenient in interactive sessions but it is best practice to\nexplicitly include the ",(0,o.kt)("inlineCode",{parentName:"p"},"and")," operator when editing Zed source files."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"not foo bar or baz\n")),(0,o.kt)("p",null,"means"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'((not grep("foo")) and grep("bar)) or grep("baz")\n')),(0,o.kt)("p",null,"while"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"foo (bar or baz)\n")),(0,o.kt)("p",null,"means"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'grep("foo") and (grep("bar)) or grep("baz"))\n')),(0,o.kt)("h2",{id:"8-lateral-subqueries"},"8. Lateral Subqueries"),(0,o.kt)("p",null,"Lateral subqueries provide a powerful means to apply a Zed query\nto each subsequence of values generated from an outer sequence of values.\nThe inner query may be ",(0,o.kt)("em",{parentName:"p"},"any Zed query")," and may refer to values from\nthe outer sequence."),(0,o.kt)("p",null,"Lateral subqueries are created using the scoped form of the\n",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/over#operator"},"over operator")," and may be nested to arbitrary depth."),(0,o.kt)("p",null,"For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{s:\"foo\",a:[1,2]} {s:\"bar\",a:[3]}' | zq -z 'over a with name=s => (yield {name,elem:this})' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{name:"foo",elem:1}\n{name:"foo",elem:2}\n{name:"bar",elem:3}\n')),(0,o.kt)("p",null,"Here the lateral scope, described below, creates a subquery"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"yield {name,elem:this}\n")),(0,o.kt)("p",null,"for each sub-sequence of values derived from each outer input value.\nIn the example above, there are two input values:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{s:"foo",a:[1,2]}\n{s:"bar",a:[3]}\n')),(0,o.kt)("p",null,"which imply two subqueries derived from the ",(0,o.kt)("inlineCode",{parentName:"p"},"over")," operator traversing ",(0,o.kt)("inlineCode",{parentName:"p"},"a"),".\nThe first subquery thus operates on the input values ",(0,o.kt)("inlineCode",{parentName:"p"},"1, 2")," with the variable\n",(0,o.kt)("inlineCode",{parentName:"p"},"name"),' set to "foo" assigning ',(0,o.kt)("inlineCode",{parentName:"p"},"1")," and then ",(0,o.kt)("inlineCode",{parentName:"p"},"2")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"this"),", thereby emitting"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{name:"foo",elem:1}\n{name:"foo",elem:2}\n')),(0,o.kt)("p",null,"and the second subquery operators on the input value ",(0,o.kt)("inlineCode",{parentName:"p"},"3")," with the variable\n",(0,o.kt)("inlineCode",{parentName:"p"},"name"),' set to "bar", emitting'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{name:"bar",elem:3}\n')),(0,o.kt)("p",null,"You can also import a parent-scope field reference into the inner scope by\nsimply referring to its name without assignment, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '{s:\"foo\",a:[1,2]} {s:\"bar\",a:[3]}' | zq -z 'over a with s => (yield {s,elem:this})' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{s:"foo",elem:1}\n{s:"foo",elem:2}\n{s:"bar",elem:3}\n')),(0,o.kt)("h3",{id:"81-lateral-scope"},"8.1 Lateral Scope"),(0,o.kt)("p",null,"A lateral scope has the form ",(0,o.kt)("inlineCode",{parentName:"p"},"=> ( <query> )")," and currently appears\nonly the context of an ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/over#operator"},"over operator"),",\nas illustrated above, and has the form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"over ... with <elem> [, <elem> ...] => ( <query> )\n")),(0,o.kt)("p",null,"where ",(0,o.kt)("inlineCode",{parentName:"p"},"<elem>")," has either an assignment form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<var>=<expr>\n")),(0,o.kt)("p",null,"or a field reference form"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<field>\n")),(0,o.kt)("p",null,"For each input value to the outer scope, the assignment form creates a binding\nbetween each ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," evaluated in the outer scope and each ",(0,o.kt)("inlineCode",{parentName:"p"},"<var>"),", which\nrepresents a new symbol in the inner scope of the ",(0,o.kt)("inlineCode",{parentName:"p"},"<query>"),".\nIn the field reference form, a single identifier ",(0,o.kt)("inlineCode",{parentName:"p"},"<id>")," refers to a field\nin the parent scope and makes that field's value available in the lateral scope\nwith the same name."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"<query>"),", which may be any Zed query, is evaluated once per outer value\non the sequence generated by the ",(0,o.kt)("inlineCode",{parentName:"p"},"over")," expression.  In the lateral scope,\nthe value ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," refers to the inner sequence generated from the ",(0,o.kt)("inlineCode",{parentName:"p"},"over")," expressions.\nThis query runs to completion for each inner sequence and emits\neach subquery result as each inner sequence traversal completes."),(0,o.kt)("p",null,"This structure is powerful because ",(0,o.kt)("em",{parentName:"p"},"any")," Zed query can be appear in the body of\nthe lateral scope.  In contrast to the ",(0,o.kt)("inlineCode",{parentName:"p"},"yield")," example, a sort could be\napplied to each sub-sequence in the subquery, where sort\nreads all of values of the subsequence, sorts them, emits them, then\nrepeats the process for the next subsequence.  For example,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '[3,2,1] [4,1,7] [1,2,3]' | zq -z 'over this => (sort this | collect(this))' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{collect:[1,2,3]}\n{collect:[1,4,7]}\n{collect:[1,2,3]}\n")),(0,o.kt)("h3",{id:"82-lateral-expressions"},"8.2 Lateral Expressions"),(0,o.kt)("p",null,"Lateral subqueries can also appear in expression context using the\nparenthesized form:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"( over <expr> [, <expr>...] [with <var>=<expr> [, ... <var>[=<expr>]] | <lateral> )\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note that the parentheses disambiguate a lateral expression from a lateral\ndataflow operator.")),(0,o.kt)("p",null,"This form must always include a lateral scope as indicated by ",(0,o.kt)("inlineCode",{parentName:"p"},"<lateral>"),",\nwhich can be any dataflow operaetor sequence excluding ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," operators.\nAs with the ",(0,o.kt)("inlineCode",{parentName:"p"},"over")," operator, values from the outer scope can be brought into\nthe lateral scope using the ",(0,o.kt)("inlineCode",{parentName:"p"},"with")," clause."),(0,o.kt)("p",null,"The lateral expression is evaluated by evalating each ",(0,o.kt)("inlineCode",{parentName:"p"},"<expr>")," and feeding\nthe results as inputs to the ",(0,o.kt)("inlineCode",{parentName:"p"},"<lateral>")," dataflow operators.  Each time the\nlateral expression is evaluated, the lateral operators are run to completion,\ne.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '[3,2,1] [4,1,7] [1,2,3]' | zq -z 'yield (over this | sum(this))' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{sum:6}\n{sum:12}\n{sum:6}\n")),(0,o.kt)("p",null,"This structure generalizes to any more complicated expression context,\ne.g., we can embed multiple lateral expressions inside of a record literal\nand use the spread operator to tighten up the output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},"echo '[3,2,1] [4,1,7] [1,2,3]' | zq -z '{...(over this | sort this | sorted:=collect(this)),...(over this | sum(this))}' -\n")),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{sorted:[1,2,3],sum:6}\n{sorted:[1,4,7],sum:12}\n{sorted:[1,2,3],sum:6}\n")),(0,o.kt)("h2",{id:"9-shaping"},"9. Shaping"),(0,o.kt)("p",null,"Data that originates from heterogeneous sources typically has\ninconsistent structure and is thus difficult to reason about or query.\nTo unify disparate data sources, data is often cleaned up to fit into\na well-defined set of schemas, which combines the data into a unified\nstore like a data warehouse."),(0,o.kt)("p",null,'In Zed, this cleansing process is called "shaping" the data and Zed leverages\nits rich, super-structured type system to perform core aspects of\ndata transformation.\nIn a data model with nesting and multiple scalar types (such as Zed or JSON),\nshaping includes converting type of leaf fields, adding or removing fields\nto "fit" a given shape, and reordering fields.'),(0,o.kt)("p",null,"While shaping remains an active area of development, the core functions in Zed\nthat currently perform shaping are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/functions/cast"},"cast")," - coerce a value to a different type"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/functions/crop"},"crop")," - remove fields from a value that are missing in a specified type"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/functions/fill"},"fill")," - add null values for missing fields"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/functions/order"},"order")," - reorder record fields"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/functions/shape"},"shape")," - apply cast, fill, and order")),(0,o.kt)("p",null,"They all have the same signature, taking two parameters: the value to be\ntransformed and a type value for the target type."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Another type of transformation that's needed for shaping is renaming fields,\nwhich is supported by the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/rename#operator"},"rename operator"),".\nAlso, the ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/operators/yield#operator"},"yield operator"),"\nis handy for simply emitting new, arbitrary record literals based on\ninput values and mixing in these shaping functions in an embedded record literal.\nThe ",(0,o.kt)("a",{parentName:"p",href:"/docs/v1.1.0/language/aggregates/fuse"},"fuse aggregate function")," is useful for fusing\nvalues into a common schema within a group-by schema though a type is returned\nrather than values.")),(0,o.kt)("p",null,"In the examples below, we will use the following named type ",(0,o.kt)("inlineCode",{parentName:"p"},"connection"),"\nthat is stored in a file ",(0,o.kt)("inlineCode",{parentName:"p"},"connection.zed"),"\nand is included in the example Zed queries with ",(0,o.kt)("inlineCode",{parentName:"p"},"-I")," option of ",(0,o.kt)("inlineCode",{parentName:"p"},"zq"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-input",metastring:"connection.zed","connection.zed":!0},"type socket = { addr:ip, port:port=uint16 }\ntype connection = {\n    kind: string,\n    client: socket,\n    server: socket,\n    vlan: uint16\n}\n")),(0,o.kt)("p",null,"We also use this sample JSON input in a file called ",(0,o.kt)("inlineCode",{parentName:"p"},"sample.json"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-input",metastring:"sample.json","sample.json":!0},'{\n  "kind": "dns",\n  "server": {\n    "addr": "10.0.0.100",\n    "port": 53\n  },\n  "client": {\n    "addr": "10.47.1.100",\n    "port": 41772\n  },\n  "uid": "C2zK5f13SbCtKcyiW5"\n}\n')),(0,o.kt)("h3",{id:"91-cast"},"9.1 Cast"),(0,o.kt)("p",null,"The cast function applies a cast operation to each leaf value that matches the\nfield path in the specified type, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -Z -I connection.zed "cast(this, <connection>)" sample.json\n')),(0,o.kt)("p",null,"casts the address fields to type ",(0,o.kt)("inlineCode",{parentName:"p"},"ip"),", the port fields to type ",(0,o.kt)("inlineCode",{parentName:"p"},"port"),"\n(which is a typedef for ",(0,o.kt)("inlineCode",{parentName:"p"},"uint16"),") and the address port pairs to\ntype ",(0,o.kt)("inlineCode",{parentName:"p"},"socket")," without modifying the ",(0,o.kt)("inlineCode",{parentName:"p"},"uid")," field or changing the\norder of the ",(0,o.kt)("inlineCode",{parentName:"p"},"server")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"client")," fields:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n    kind: "dns",\n    server: {\n        addr: 10.0.0.100,\n        port: 53 (port=uint16)\n    } (=socket),\n    client: {\n        addr: 10.47.1.100,\n        port: 41772\n    } (socket),\n    uid: "C2zK5f13SbCtKcyiW5"\n}\n')),(0,o.kt)("h3",{id:"92-crop"},"9.2 Crop"),(0,o.kt)("p",null,'Cropping is a useful when you want records to "fit" a schema tightly, e.g.,'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -Z -I connection.zed "crop(this, <connection>)" sample.json\n')),(0,o.kt)("p",null,"removes the ",(0,o.kt)("inlineCode",{parentName:"p"},"uid")," field since it is not in the ",(0,o.kt)("em",{parentName:"p"},"connection")," type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n    kind: "dns",\n    server: {\n        addr: "10.0.0.100",\n        port: 53\n    },\n    client: {\n        addr: "10.47.1.100",\n        port: 41772\n    }\n}\n')),(0,o.kt)("h3",{id:"93-fill"},"9.3 Fill"),(0,o.kt)("p",null,"Use fill when you want to fill out missing fields with nulls, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -Z -I connection.zed "fill(this, <connection>)" sample.json\n')),(0,o.kt)("p",null,"adds a null-valued ",(0,o.kt)("inlineCode",{parentName:"p"},"vlan")," field since the input value is missing it and\nthe ",(0,o.kt)("em",{parentName:"p"},"connection")," type has it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n    kind: "dns",\n    server: {\n        addr: "10.0.0.100",\n        port: 53\n    },\n    client: {\n        addr: "10.47.1.100",\n        port: 41772\n    },\n    uid: "C2zK5f13SbCtKcyiW5",\n    vlan: null (uint16)\n}\n')),(0,o.kt)("h3",{id:"94-order"},"9.4 Order"),(0,o.kt)("p",null,"The order function changes the order of fields in its input to match the\nspecified order, as field order is significant in Zed records, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -Z -I connection.zed "order(this, <connection>)" sample.json\n')),(0,o.kt)("p",null,"reorders the ",(0,o.kt)("inlineCode",{parentName:"p"},"client")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"server")," fields to match the input but does nothing\nabout the ",(0,o.kt)("inlineCode",{parentName:"p"},"uid")," field as it is not in the ",(0,o.kt)("em",{parentName:"p"},"connection")," type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n    kind: "dns",\n    client: {\n        addr: "10.47.1.100",\n        port: 41772\n    },\n    server: {\n        addr: "10.0.0.100",\n        port: 53\n    },\n    uid: "C2zK5f13SbCtKcyiW5"\n}\n')),(0,o.kt)("h3",{id:"95-shape"},"9.5 Shape"),(0,o.kt)("p",null,"The shape function brings everything together by applying ",(0,o.kt)("inlineCode",{parentName:"p"},"cast"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"fill"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"order")," all in one step, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -Z -I connection.zed "shape(this, <connection>)" sample.json\n')),(0,o.kt)("p",null,"reorders the ",(0,o.kt)("inlineCode",{parentName:"p"},"client")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"server")," fields to match the input but does nothing\nabout the ",(0,o.kt)("inlineCode",{parentName:"p"},"uid")," field as it is not in the ",(0,o.kt)("em",{parentName:"p"},"connection")," type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n    kind: "dns",\n    client: {\n        addr: 10.47.1.100,\n        port: 41772 (port=uint16)\n    } (=socket),\n    server: {\n        addr: 10.0.0.100,\n        port: 53\n    } (socket),\n    vlan: null (uint16),\n    uid: "C2zK5f13SbCtKcyiW5"\n}\n')),(0,o.kt)("p",null,"To get a tight shape of the target type,\napply ",(0,o.kt)("inlineCode",{parentName:"p"},"crop")," to the output of ",(0,o.kt)("inlineCode",{parentName:"p"},"shape"),", e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'zq -Z -I connection.zed "shape(this, <connection>) | crop(this, <connection>)" sample.json\n')),(0,o.kt)("p",null,"drops the ",(0,o.kt)("inlineCode",{parentName:"p"},"uid")," field after shaping:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{\n    kind: "dns",\n    client: {\n        addr: 10.47.1.100,\n        port: 41772 (port=uint16)\n    } (=socket),\n    server: {\n        addr: 10.0.0.100,\n        port: 53\n    } (socket),\n    vlan: null (uint16)\n}\n')),(0,o.kt)("h2",{id:"10-type-fusion"},"10. Type Fusion"),(0,o.kt)("p",null,'Type fusion is another important building block of data shaping.\nHere, types are operated upon by fusing them together, where the\nresult is single fused type.\nSome systems call a related process "schema inference" where a set\nof values, typically JSON, is analyzed to determine a relational schema\nthat all the data will fit into.  However, this is just a special case of\ntype fusion as fusion is fine-grained and based on Zed\'s type system rather\nthan having the narrower goal of computing a schema for representations\nlike relational tables, Parquet, Avro, etc.'),(0,o.kt)("p",null,"Type fusion utilizes two key techniques."),(0,o.kt)("p",null,"The first technique is to simply combine types with a type union.\nFor example, an ",(0,o.kt)("inlineCode",{parentName:"p"},"int64")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," can be merged into a common\ntype of union ",(0,o.kt)("inlineCode",{parentName:"p"},"(int64,string)"),", e.g., the value sequence ",(0,o.kt)("inlineCode",{parentName:"p"},'1 "foo"'),"\ncan be fused into the single-type sequence:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'1((int64,string))\n"foo"((int64,string))\n')),(0,o.kt)("p",null,"The second technique is to merge fields of records, analogous to a spread\nexpression.  Here, the value sequence ",(0,o.kt)("inlineCode",{parentName:"p"},'{a:1}{b:"foo"}')," may be\nfused into the single-type sequence:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{a:1,b:null(string)}\n{a:null(int64),b:"foo"}\n')),(0,o.kt)("p",null,"Of course, these two techniques can be powerfully combined,\ne.g., where the value sequence ",(0,o.kt)("inlineCode",{parentName:"p"},'{a:1}{a:"foo",b:2}')," may be\nfused into the single-type sequence:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'{a:1((int64,string)),b:null(int64)}\n{a:"foo"((int64,string)),b:2}\n')),(0,o.kt)("p",null,"To perform fusion, Zed currently includes two key mechanisms\n(though this is an active area of development):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/operators/fuse#operator"},"fuse operator"),", and"),(0,o.kt)("li",{parentName:"ul"},"the ",(0,o.kt)("a",{parentName:"li",href:"/docs/v1.1.0/language/aggregates/fuse"},"fuse aggregate function"),".")),(0,o.kt)("h3",{id:"101-fuse-operator"},"10.1 Fuse Operator"),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"fuse operator")," reads all of its input, computes a fused type using\nthe techniques above, and outputs the result, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{x:1} {y:"foo"}{x:2,y:"bar"}\' | zq -z fuse -\n')),(0,o.kt)("p",null,"produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{x:1,y:null(string)}\n{x:null(int64),y:"foo"}\n{x:2,y:"bar"}\n')),(0,o.kt)("p",null,"whereas"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{x:1} {x:"foo",y:"foo"}{x:2,y:"bar"}\' | zq -z fuse -\n')),(0,o.kt)("p",null,"requires a type union for field ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and produces:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{x:1((int64,string)),y:null(string)}\n{x:"foo"((int64,string)),y:"foo"}\n{x:2((int64,string)),y:"bar"}\n')),(0,o.kt)("h3",{id:"102-fuse-function"},"10.2 Fuse Function"),(0,o.kt)("p",null,"The ",(0,o.kt)("em",{parentName:"p"},"fuse function")," is most often useful during data exploration and discovery\nwhere you might interactively run queries to determine the shapes of some new\nor unknown input data and how those various shapes relate to one another."),(0,o.kt)("p",null,"For example, in example sequence above, we can use the ",(0,o.kt)("em",{parentName:"p"},"fuse function")," to determine\nthe fused type rather than transforming the values, e.g.,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{x:1} {x:"foo",y:"foo"}{x:2,y:"bar"}\' | zq -z \'fuse(this)\' -\n')),(0,o.kt)("p",null,"results in"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{fuse:<{x:(int64,string),y:string}>}\n")),(0,o.kt)("p",null,"Since the ",(0,o.kt)("em",{parentName:"p"},"fuse")," here is an aggregate function, it can also be used with\ngroup-by keys.  Supposing we wanted to fuse different type records into\ndifferent types, we can use a group-by.  In this simple example, we will\nfuse records based on their number of fields using the ",(0,o.kt)("inlineCode",{parentName:"p"},"len()")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{x:1} {x:"foo",y:"foo"}{x:2,y:"bar"}\' | zq -z \'fuse(this) by len(this) | sort len\' -\n')),(0,o.kt)("p",null,"which produces"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},"{len:1,fuse:<{x:int64}>}\n{len:2,fuse:<{x:(int64,string),y:string}>}\n")),(0,o.kt)("p",null,'Now, we can turn around and write a "shaper" for data that has the patterns\nwe "discovered" above, e.g., if this Zed source is in ',(0,o.kt)("inlineCode",{parentName:"p"},"shape.zed")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-input",metastring:"shape.zed","shape.zed":!0},'switch len(this) (\n    case 1 => pass\n    case 2 => yield shape(this, <{x:(int64,string),y:string}>)\n    default => yield error({kind:"unrecognized shape",value:this})\n)\n')),(0,o.kt)("p",null,"when we run"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-command"},'echo \'{x:1} {x:"foo",y:"foo"}{x:2,y:"bar"}{a:1,b:2,c:3}\' | zq -z -I shape.zed \'| sort -r this\' -\n')),(0,o.kt)("p",null,"we get"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-mdtest-output"},'{x:1}\n{x:"foo"((int64,string)),y:"foo"}\n{x:2((int64,string)),y:"bar"}\nerror({kind:"unrecognized shape",value:{a:1,b:2,c:3}})\n')))}c.isMDXComponent=!0}}]);